################################################################################
#    Creme is a free/open-source Customer Relationship Management software
#    Copyright (C) 2025  Hybird
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
################################################################################

# The Workflow system allows users to configure some actions (like Relationship
# creation or email sending) which are made automatically in some conditions
# E.g: IF an instance of 'StuffEntity' is created, AND IF its field "status" is
#      <Very important>, THEN an email is sent to the owner of the new instance.
from __future__ import annotations

import enum
import logging
import re
from collections.abc import Iterable, Iterator
from typing import TYPE_CHECKING

from django.contrib.contenttypes.models import ContentType
from django.db.models import Model, QuerySet, signals
from django.dispatch import receiver
from django.utils.html import format_html, format_html_join
from django.utils.translation import gettext as _

from ..global_info import get_per_request_cache
from ..models import (
    CremeEntity,
    CremeProperty,
    EntityFilterCondition,
    Relation,
)
from ..models.utils import model_verbose_name
from .entity_filter import (
    EntityFilterRegistry,
    condition_handler,
    entity_filter_registries,
    operators,
)
from .snapshot import Snapshot

if TYPE_CHECKING:
    from django.forms import Field as FormField

    from creme.creme_core.forms.workflows import BaseWorkflowActionForm
    from creme.creme_core.models import CremeUser


logger = logging.getLogger(__name__)


class WorkflowBrokenData(Exception):
    """Stored data which describe a Workflow is invalid."""
    pass


# Utils ------------------------------------------------------------------------

# Consistent with 'creme_core.utils.content_type.ctype_as_key()'
def model_as_key(model: type[Model]) -> str:
    meta = model._meta
    return f'{meta.app_label}.{meta.model_name}'


def model_from_key(model_key: str) -> type[Model]:
    """Build a model class from a string-key generated by 'model_to_key()'.
    @raise WorkflowBrokenData
    """
    try:
        return ContentType.objects.get_by_natural_key(*model_key.split('.', 1)).model_class()
    except ContentType.DoesNotExist as e:
        # NB: this error could happen in real life if administrator uninstall a
        #     used app, so we produce a human-friendly message
        raise WorkflowBrokenData(
            _('The model «{key}» is invalid').format(key=model_key)
        ) from e
    except TypeError as e:
        raise WorkflowBrokenData(
            'Invalid key for model: "{key}" (original error <{e}>)'
        ) from e


# Events -----------------------------------------------------------------------
# TODO: __slots__?
class WorkflowEvent:
    """Represents events like <a Contact has been created> or
    <an Activity has been modified>. These events are pushed to a queue (see
    WorkflowEventQueue) in order to be managed later.
    """
    def inhibits(self, /, other: WorkflowEvent) -> bool:
        """Is this event preventing another event to be inserted in the same queue."""
        return False


class _EntityEvent(WorkflowEvent):
    """Event representing the creation of a CremeEntity instance."""
    def __init__(self, entity: CremeEntity):
        self._entity = entity

    def __eq__(self, other):
        return isinstance(other, type(self)) and self._entity.id == other._entity.id

    def __repr__(self):
        return f'{type(self).__name__}(entity={self._entity!r})'

    @property
    def entity(self) -> CremeEntity:
        return self._entity


class EntityCreated(_EntityEvent):
    """Event representing the creation of a CremeEntity instance."""

    def inhibits(self, /, other):
        # If the entity just has been created, we prevent other calls to save()
        # to trigger the edition
        return isinstance(other, EntityEdited) and self._entity.id == other._entity.id


class EntityEdited(_EntityEvent):
    """Event representing the modification of a CremeEntity instance."""


class PropertyAdded(WorkflowEvent):
    """Event representing the creation of a CremeProperty instance."""
    def __init__(self, creme_property: CremeProperty):
        self._property = creme_property

    def __eq__(self, other):
        return isinstance(other, type(self)) and self._property.id == other._property.id

    def __repr__(self):
        return f'PropertyAdded(creme_property={self._property!r})'

    @property
    def creme_property(self) -> CremeProperty:
        return self._property


class RelationAdded(WorkflowEvent):
    """Event representing the creation of a Relation instance."""
    def __init__(self, relation: Relation):
        self._relation = relation

    def __eq__(self, other):
        return isinstance(other, type(self)) and self._relation.id == other._relation.id

    def __repr__(self):
        return f'RelationAdded(relation={self._relation})'

    @property
    def relation(self) -> Relation:
        return self._relation


class WorkflowEventQueue:
    """Queue containing instances of WorkflowEvent.
    The idea is to create & push the instances in signal handlers, and manage
    (i.e. apply WorkflowActions) the events later (i.e. when the response is built),
    with a middleware (see 'creme_core.middleware.workflow.WorkflowMiddleware').
    """
    _events: list[WorkflowEvent]

    def __init__(self):
        self._events = []

    def __bool__(self):
        return bool(self._events)

    def __len__(self):
        return len(self._events)

    def append(self, event: WorkflowEvent) -> WorkflowEventQueue:
        """Append a new event:
            - if not already here.
            - if not inhibited by another event in the queue.
         """
        events = self._events
        if not any(event == queued or queued.inhibits(event) for queued in events):
            events.append(event)

        return self

    def pickup(self, start=0) -> list[WorkflowEvent]:
        """Retrieve all contained events after a given index as a list.
        The returned events are removed from the queue.
        Useful to treat events & avoid recursion issues.
        @param start: Index of the first event we want to retrieve.
        """
        events = self._events
        self._events, picked = events[:start], events[start:]

        return picked


# Triggers ---------------------------------------------------------------------
class WorkflowTrigger:
    """Part of a workflow containing the kind of WorkflowEvent which
    triggers this workflow (e.g. the workflow is triggered when a Contact is created).
    """
    # Must be unique by class; used by the registry for deserialize from the database.
    type_id = ''
    verbose_name = '??'

    # NB: override in child classes
    event_class = WorkflowEvent

    # Behaviour of the related WorkflowConditions:
    conditions_use_or = False  # accept()'s "use_or" argument
    conditions_detect_change = False  # accept()'s "detect_change" argument

    def _activate(self, event: WorkflowEvent) -> dict | None:
        """See 'activate()'."""
        raise NotImplementedError

    def activate(self, event: WorkflowEvent) -> dict | None:
        """Indicates if the workflow is triggered and build the context to be
        used by other partys of the workflows.
        @return <None> if the workflow is not triggered.
                The context (a dictionary) if the workflow is triggered; it
                contains WorkflowSource instance(s).

        BEWARE: see the method 'root_sources()' too.
        """
        return self._activate(event) if isinstance(event, self.event_class) else None

    @classmethod
    def config_formfield(cls, model: type[CremeEntity]) -> FormField:
        """Returns a form field which builds an instance of this trigger class.
        This field will be aggregated by 'creme_config.forms.workflow.TriggerField'
        in order to be used to configure the trigger part of the Workflow.

        @param model: Model corresponding to the 'creme_core.models.WorkFlow' instance.
        @return A field which 'clean()' method builds an instance of 'WorkflowTrigger'.
        """
        raise NotImplementedError

    @property
    def description(self) -> str:
        """A localized human-friendly string used in the configuration brick."""
        raise NotImplementedError

    @classmethod
    def from_dict(cls, data: dict) -> WorkflowTrigger:
        """Builds an instance from a dictionary (produced by the method 'to_dict()').
        @raise WorkflowBrokenData.
        """
        raise NotImplementedError

    def to_dict(self) -> dict:
        """Serialize into a JSON-friendly dictionary (which can be stored in database)."""
        return {'type': self.type_id}

    def root_sources(self) -> list[WorkflowSource]:
        """A trigger produces at least one source (i.e. an instance of
        'CremeEntity' to act on).
        BEWARE: these sources must correspond to the entities injected in the
                context by the method 'activate()'.
        """
        raise NotImplementedError


class BrokenTrigger(WorkflowTrigger):
    def __init__(self, message: str):
        self._message = message

    @property
    def message(self):
        return self._message

    def activate(self, event):
        # TODO: log?
        return None

    @property
    def description(self):
        return format_html('<p class="errorlist">{message}</p>', message=self.message)


# Sources ----------------------------------------------------------------------
class WorkflowSource:
    """A Source can retrieve a CremeEntity instance related to the current Trigger.
    - The conditions of the Workflow can check this entity (to know if the
      Actions have to be performed).
    - The Actions of the Workflow can use it to perform their work.

    Some sources can extract their CremeEntity instance directly from the context
    generated by an activated Trigger; we call them the 'root' sources.
     E.g.: the trigger 'creme_core.workflows.EntityCreationTrigger' creates a
           context containing the created instance; then the source
           'creme_core.workflows.CreatedEntitySource' can extract this instance
           from the context (so the concerned WorkflowAction can use it).
    Note that conditions are only checking these root sources.

    Some sources can retrieve their CremeEntity instance directly from the DB;
    they do not use the context generated by the trigger, directly or through a
    sub-source. We call them 'standalone' sources.
     E.g.: 'creme_core.workflows.FixedEntitySource' retrieves its entity by its uuid.

    Some sources need another source to provide a CremeEntity instance.
     E.g.: 'creme_core.workflows.EntityFKSource' needs a CremeEntity with a
           ForeignKey referencing another CremeEntity instance.
    """
    # Must be unique by class; used by the registry for deserialize from the database.
    type_id = ''
    # Description of the type (used for error).
    # Hint: use 'render()' to get a description of an instance.
    verbose_name = '??'

    class RenderMode(enum.Enum):
        TEXT_PLAIN = enum.auto()
        HTML = enum.auto()

    @classmethod
    def standalone_config_formfield(cls, user: CremeUser) -> FormField | None:
        """Returns a form field which builds an instance of this source class
        when it's a standalone source.
        This field will be aggregated by 'creme_config.forms.workflow.SourceField'
        in order to be used to configure the action part of the Workflow.

        @return A field which 'clean()' method builds an instance of
                'WorkflowSource', or None for not standalone sources.
        """
        return None

    @classmethod
    def composed_config_formfield(cls,
                                  sub_source: WorkflowSource,
                                  user: CremeUser,
                                  ) -> FormField | None:
        """Returns a form field which builds an instance of this source class
        when it needs a sub-source (not a root or a standalone source).
        This field will be aggregated by 'creme_config.forms.workflow.SourceField'
        in order to be used to configure the action part of the Workflow.

        @return A field which 'clean()' method builds an instance of
                'WorkflowSource' it this kind of source uses another sub-source.
                None for root/standalone sources.
        """
        return None

    def config_formfield(self, user: CremeUser) -> FormField:
        """Returns a form field which builds an instance of this source class.
        This field will be aggregated by 'creme_config.forms.workflow.SourceField'
        in order to be used to configure the action part of the Workflow.

        It works only with source classes designed to be root source; see the
        method 'composed_config_formfield()' for types of source needing another
        sub-source.

        @return A field which 'clean()' method builds an instance of
               'WorkflowSource'.
        @raise A ValueError if this not a root source.
        """
        raise ValueError('This type of source cannot be used as root source')

    @classmethod
    def config_formfield_kind_id(cls, sub_source: WorkflowSource | None = None) -> str:
        """Generate an ID for the related configuration form-field.
        This ID is used by 'creme_core.forms.workflows.SourceField' to
        distinguish the different kinds of source.
        Hint: you probably don't have to override this method in child classes.
        @parameter sub_source: Should the same sub-source used by the field itself.
        """
        return (
            cls.type_id
            if sub_source is None else
            f'{sub_source.config_formfield_kind_id()}|{cls.type_id}'
        )

    def extract(self, context: dict) -> CremeEntity | None:
        """Extract a CremeEntity from the context (generated by the trigger).
        @return A CremeEntity instance, or <None> (e.g. the used FK is 'null').
        """
        raise NotImplementedError

    @property
    def model(self) -> type[CremeEntity]:
        """Indicates what kind of entity the source will extract.
        It's important because the conditions & actions can need to know the model
        (e.g. they use a specific model field).
        """
        raise NotImplementedError

    @classmethod
    def from_dict(cls, data: dict, registry: WorkflowRegistry) -> WorkflowSource:
        """Builds an instance from a dictionary (produced by the method 'to_dict()').
        The registry is useful to build the 'non-root' sources.
        """
        raise NotImplementedError

    def to_dict(self) -> dict:
        """Serialize into a JSON-friendly dictionary (which can be stored in database)."""
        return {'type': self.type_id}

    def render(self, user: CremeUser, mode: RenderMode) -> str:
        """Render a string (plain text or HTML) which can be used to describe
        the source to the users.
        Plain text is used in configuration form-fields.
        HTML is used in configuration brick.
        """
        raise NotImplementedError

    @property
    def sub_source(self) -> WorkflowSource | None:
        """Some source classes extract their entities from another source.
        E.g.: creme_core.workflows.EntityFKSource
        @return The sub-source, or 'None' if no sub-source is used.
        """
        return None


# TODO: unit tests
class FromContextSource(WorkflowSource):
    """Base class for sources which extract their CremeEntity from the context
    generated by a trigger.
    """
    description_format = 'Entity ({type})'

    def __init__(self, model: type[CremeEntity]):
        # assert issubclass(model, CremeEntity)
        self._model = model

    def __eq__(self, other):
        return isinstance(other, type(self)) and self._model == other._model

    def __repr__(self):
        return f'{type(self).__name__}(model={self._model.__name__})'

    @property
    def model(self):
        return self._model

    def extract(self, context):
        # TODO: use get()? log?
        return context[self.type_id]

    @classmethod
    def from_dict(cls, data, registry) -> FromContextSource:
        return cls(model=model_from_key(data['model']))

    def to_dict(self):
        d = super().to_dict()
        d['model'] = model_as_key(self._model)

        return d

    def _label(self):
        return self.description_format.format(type=model_verbose_name(self._model))

    def render(self, user, mode):
        return self._label()


class BrokenSource(WorkflowSource):
    def __init__(self, message):
        self._message = message

    @property
    def message(self):
        return self._message

    def extract(self, context):
        return None

    @property
    def model(self):
        raise WorkflowBrokenData(self._message)

    def render(self, user, mode):
        match mode:
            case self.RenderMode.HTML:
                return format_html(
                    '<p class="errorlist">{message}</p>',
                    message=self._message,
                )

            case self.RenderMode.TEXT_PLAIN:
                return _('Error ({message})').format(message=self._message)

            case _:
                raise ValueError()


# Conditions ----------------------------------------------------------------------
wf_efilter_registry = EntityFilterRegistry(
    id='creme_core-workflow',  # Not used
    verbose_name='Workflow conditions',  # Not used
).register_condition_handlers(
    condition_handler.RegularFieldConditionHandler,
    condition_handler.DateRegularFieldConditionHandler,

    condition_handler.CustomFieldConditionHandler,
    condition_handler.DateCustomFieldConditionHandler,

    # TODO?
    # condition_handler.RelationConditionHandler,
    # condition_handler.PropertyConditionHandler,

    # NOPE
    # RelationSubFilterConditionHandler,
    # SubFilterConditionHandler,
).register_operators(
    *operators.all_operators,
)
# TODO?
# .register_operands(
#     *operands.all_operands,
# )
entity_filter_registries.register(wf_efilter_registry)


class WorkflowConditions:
    """It stores EntityFilterCondition instances for the root Source of a Workflow."""
    def __init__(self):
        self._conditions_per_source: list[dict] = []

    @classmethod
    def from_dicts(cls, data: list[dict], registry: WorkflowRegistry) -> WorkflowConditions:
        """Deserialize an instance from data generated by the method to_dicts()."""
        instance = cls()
        instance._conditions_per_source = conditions_per_source = []

        for d in data:
            source = registry.build_source(d['entity'])
            conditions_per_source.append({
                'entity': source,
                'conditions': [
                    EntityFilterCondition(
                        filter=None,
                        filter_type=wf_efilter_registry.id,
                        model=source.model,
                        type=data['type'],
                        name=data['name'],
                        value=data['value'],
                    ) for data in d['conditions']
                ],
            })

        return instance

    def accept(self, *,
               user: CremeUser,
               context: dict,
               detect_change: bool,
               use_or: bool,
               ) -> bool:
        """Do the entities of a Workflow context fill the conditions?
        @param user: Logged user.
        @param context: see dictionary generated by 'WorkflowTrigger.activate()'.
        @param detect_change: <True> means an entity fill its condition if its
               current check the conditions but its initial state (just after the
               loading from the DB) doesn't check them (i.e. the changes happened
               during the request handling make the conditions pass).
        @param use_or: <True> means OR is used between conditions;
                       <False> means AND is used between conditions.
        @return <True> the conditions are filled.
        """
        def accepted():
            for source_conditions in self._conditions_per_source:
                entity = source_conditions['entity'].extract(context)

                if detect_change:
                    snapshot = Snapshot.get_for_instance(entity)
                    if snapshot is None:
                        raise ValueError(
                            'The "detect_edition" mode work only with edited entities'
                        )

                    previous = snapshot.get_initial_instance()

                    for condition in source_conditions['conditions']:
                        yield (
                            condition.accept(entity=entity, user=user)
                            and not condition.accept(entity=previous, user=user)
                        )
                else:
                    for condition in source_conditions['conditions']:
                        yield condition.accept(entity=entity, user=user)

        if use_or:
            # NB: 'any()' returns 'False' on empty sequences
            empty = True
            for cond_accepted in accepted():
                empty = False
                if cond_accepted:
                    return True

            return empty

        return all(accepted())

    def add(self,
            source: WorkflowSource,
            conditions: Iterable[EntityFilterCondition],
            ) -> WorkflowConditions:
        """Add the conditions related to a WorkflowSource.
        @return "self" to chain calls.
        """
        # TODO: merge conditions for the same source
        self._conditions_per_source.append({
            'entity': source, 'conditions': [*conditions],
        })

        return self

    def conditions_for_source(self, source: WorkflowSource) -> list[EntityFilterCondition]:
        """Returns the conditions corresponding to a specific source."""
        for source_conditions in self._conditions_per_source:
            if source == source_conditions['entity']:
                return source_conditions['conditions']

        return []

    def descriptions(self, user: CremeUser) -> Iterator[str]:
        """Returns localised HTML strings which describe the conditions."""
        for source_conditions in self._conditions_per_source:
            source: WorkflowSource = source_conditions['entity']
            rendered_source = source.render(user=user, mode=source.RenderMode.HTML)

            conditions = source_conditions['conditions']
            if conditions:
                yield format_html(
                    '{label}<ul>{conditions}</ul>',
                    label=_('Conditions on «{source}»:').format(
                        source=rendered_source,
                    ),
                    conditions=format_html_join(
                        '', '<li>{}</li>',
                        ([condition.description(user=user)] for condition in conditions)
                    ),
                )
            else:
                yield _('No condition on «{source}»').format(source=rendered_source)

    def to_dicts(self) -> list[dict]:
        """Serialize the instance as a JSON-friendly list of dictionaries."""
        return [
            {
                'entity': source_conditions['entity'].to_dict(),
                'conditions': [
                    {
                        'type': condition.type,
                        'name': condition.name,
                        'value': condition.value,
                    } for condition in source_conditions['conditions']
                ],
            } for source_conditions in self._conditions_per_source
        ]


# Action -----------------------------------------------------------------------
class WorkflowAction:
    """Part of a Workflow with performs "concrete" things (adds CremeProperties,
    sends emails etc...).
    """
    # Must be unique by class; used by the registry for deserialize from the database.
    type_id = ''
    verbose_name = '??'

    def __str__(self):
        return str(self.verbose_name)

    @classmethod
    def config_form_class(cls) -> BaseWorkflowActionForm:
        """Returns a configuration form for this kind of action."""
        raise NotImplementedError

    def execute(self, context: dict, user: CremeUser | None = None) -> None:
        """Perform the action (add RelationShips etc...).
        @param context: The context generated by the trigger of the concerned Workflow.
        @param user: Logged user; <None> if code is run outside a request handling.
        """
        raise NotImplementedError

    @classmethod
    def from_dict(cls, data: dict, registry: WorkflowRegistry) -> WorkflowAction:
        """Builds an instance from a dictionary (produced by the method 'to_dict()').
        The registry is useful to build the 'non-root' sources.
        """
        raise NotImplementedError

    def to_dict(self) -> dict:
        """Serialize into a JSON-friendly dictionary (which can be stored in database)."""
        return {'type': self.type_id}

    # TODO: add a "mode" argument (for TEXT_PLAIN)?
    def render(self, user) -> str:
        """Render as an HTML string which can be used to describe the source to
        the users.
        """
        raise NotImplementedError


class BrokenAction(WorkflowAction):
    """Used to represent an Action which has been badly loaded."""
    def __init__(self, message):
        self._message = message

    @property
    def message(self):
        return self._message

    def execute(self, *args, **kwargs):
        # TODO: log?
        pass

    def render(self, user):
        return format_html('<p class="errorlist">{message}</p>', message=self.message)


# Registry ---------------------------------------------------------------------
class WorkflowRegistry:
    """Registry related to these aspects of the Workflow engine:
     - triggers
     - sources
     - actions
    """
    type_id_re = re.compile(r'[A-Za-z0-9_-]*')  # TODO: in utils?

    class RegistrationError(Exception):
        pass

    class UnRegistrationError(RegistrationError):
        pass

    _source_classes: dict[str, type[WorkflowSource]]
    _action_classes: dict[str, type[WorkflowAction]]
    _trigger_classes: dict[str, type[WorkflowTrigger]]

    def __init__(self):
        self._source_classes = {}
        self._action_classes = {}
        self._trigger_classes = {}

    @classmethod
    def checked_type_id(cls, registrable_cls) -> str:
        type_id = registrable_cls.type_id

        if not type_id:
            raise cls.RegistrationError(
                f'This class has an empty ID: {registrable_cls}'
            )

        if cls.type_id_re.fullmatch(type_id) is None:
            raise cls.RegistrationError(
                f'This class uses has an ID with invalid chars: {registrable_cls}'
            )

        return type_id

    # Actions ---
    def get_action_class(self, type_id: str) -> type[WorkflowAction] | None:
        return self._action_classes.get(type_id)

    @property
    def action_classes(self) -> Iterator[type[WorkflowAction]]:
        yield from self._action_classes.values()

    def build_action(self, data: dict) -> WorkflowAction:
        """Build a WorkflowAction instance from a serialized action."""
        type_id = data['type']
        action_cls = self._action_classes.get(type_id)
        if action_cls is None:
            return BrokenAction(
                message=_(
                    'The type of action «{type}» is invalid (uninstalled app?)'
                ).format(type=type_id),
            )

        try:
            action = action_cls.from_dict(data=data, registry=self)
        except Exception as e:
            action = BrokenAction(
                message=_(
                    'The action «{name}» is broken (original error: {error})'
                ).format(name=action_cls.verbose_name, error=e),
            )

        return action

    def register_actions(self, *action_classes: type[WorkflowAction]) -> WorkflowRegistry:
        set_action = self._action_classes.setdefault

        for action_cls in action_classes:
            if set_action(self.checked_type_id(action_cls), action_cls) is not action_cls:
                raise self.RegistrationError(
                    f'This action class uses a duplicated ID: {action_cls}'
                )

        return self

    def unregister_actions(self,
                           *action_classes: type[WorkflowAction],
                           ) -> WorkflowRegistry:
        for action_cls in action_classes:
            try:
                del self._action_classes[action_cls.type_id]
            except KeyError as e:
                raise self.UnRegistrationError(
                    f'This action class is not registered: {action_cls}'
                ) from e

        return self

    # Sources ---
    @property
    def source_classes(self) -> Iterator[type[WorkflowSource]]:
        yield from self._source_classes.values()

    def source_formfields(self,
                          root_sources: Iterable[WorkflowSource],
                          user: CremeUser,
                          ) -> list[tuple[str, FormField]]:
        """Generates all the form fields which allow to choose/configure a WorkflowSource.
        It's used to create complex fields like 'creme_core.forms.workflows.SourceField'.
        @param root_sources: the sources which the fields are related to.
               The generated fields contain :
                - the fields directly related to the root sources
                - standalone fields (see 'WorkflowSource.standalone_config_formfield()').
                - composed fields derived from the root sources
                  (see 'WorkflowSource.composed_config_formfield()').
        @param user: Logged user.
        @return list of tuple (string_ID, form_field); the ID can be used to
                distinguish the different form fields.
        """
        # TODO: check that root source classes are registered?
        fields = [
            (source.config_formfield_kind_id(), source.config_formfield(user=user))
            for source in root_sources
        ]

        for source_cls in self._source_classes.values():
            field = source_cls.standalone_config_formfield(user=user)
            if field is not None:
                fields.append((source_cls.config_formfield_kind_id(), field))

        for sub_source in root_sources:
            for source_cls in self._source_classes.values():
                field = source_cls.composed_config_formfield(
                    sub_source=sub_source, user=user,
                )
                if field is not None:
                    fields.append((
                        source_cls.config_formfield_kind_id(sub_source=sub_source),
                        field,
                    ))

        return fields

    def build_source(self, data: dict) -> WorkflowSource:
        """Build a WorkflowSource instance from a serialized source."""
        type_id = data['type']
        source_cls = self._source_classes.get(type_id)
        if source_cls is None:
            return BrokenSource(
                message=_(
                    'The type of source «{type}» is invalid (uninstalled app?)'
                ).format(type=type_id),
            )

        try:
            source = source_cls.from_dict(data=data, registry=self)
        except Exception as e:
            source = BrokenSource(
                message=_(
                    'The source «{name}» is broken (original error: {error})'
                ).format(name=source_cls.verbose_name, error=e),
            )

        return source

    def register_sources(self,
                         *source_classes: type[WorkflowSource],
                         ) -> WorkflowRegistry:
        set_source = self._source_classes.setdefault

        for source_cls in source_classes:
            if set_source(self.checked_type_id(source_cls), source_cls) is not source_cls:
                raise self.RegistrationError(
                    f'This source class uses a duplicated ID: {source_cls}'
                )

        return self

    def unregister_sources(self,
                           *source_classes: type[WorkflowSource],
                           ) -> WorkflowRegistry:
        for source_cls in source_classes:
            try:
                del self._source_classes[source_cls.type_id]
            except KeyError as e:
                raise self.UnRegistrationError(
                    f'This source class is not registered: {source_cls}'
                ) from e

        return self

    # Triggers ---
    @property
    def trigger_classes(self) -> Iterator[type[WorkflowTrigger]]:
        yield from self._trigger_classes.values()

    def build_trigger(self, data: dict) -> WorkflowTrigger:
        """Build a WorkflowTrigger instance from a serialized trigger."""
        type_id = data['type']
        trigger_cls = self._trigger_classes.get(type_id)
        if trigger_cls is None:
            return BrokenTrigger(
                message=_(
                    'The type of trigger «{type}» is invalid (uninstalled app?)'
                ).format(type=type_id),
            )

        try:
            trigger = trigger_cls.from_dict(data)
        except Exception as e:
            trigger = BrokenTrigger(
                message=_(
                    'The trigger «{name}» is broken (original error: {error})'
                ).format(name=trigger_cls.verbose_name, error=e),
            )

        return trigger

    def register_triggers(self,
                          *trigger_classes: type[WorkflowTrigger],
                          ) -> WorkflowRegistry:
        set_trigger = self._trigger_classes.setdefault

        for trigger_cls in trigger_classes:
            if set_trigger(self.checked_type_id(trigger_cls), trigger_cls) is not trigger_cls:
                raise self.RegistrationError(
                    f'This trigger class uses a duplicated ID: {trigger_cls}'
                )

        return self

    def unregister_triggers(self,
                            *trigger_classes: type[WorkflowTrigger],
                            ) -> WorkflowRegistry:
        for trigger_cls in trigger_classes:
            try:
                del self._trigger_classes[trigger_cls.type_id]
            except KeyError as e:
                raise self.UnRegistrationError(
                    f'This trigger class is not registered: {trigger_cls}'
                ) from e

        return self


workflow_registry = WorkflowRegistry()


# Engine -----------------------------------------------------------------------
class WorkflowEngine:
    """Class which runs the configured Workflows.

    It's designed as a singleton per request (see the method 'get_current()'),
    which owns the instance of WorkflowEventQueue used for the current request.

    As explained in the WorkflowEventQueue's documentation, we do not manage an
    event (like an entity creation) directly in a signal handler; instead we
    push this event (see _push_event_for*()) in the queue, and we treat this
    event when the entity is "complete".
    When you save() a CremeEntity instance, its ManyToManyFields (or CustomFields/
    Relations/CremeProperties/...) are not up-to-date yet with the values the
    user just has submitted. If the workflow system handled the event directly,
    it would not work as the user expect:
     - the conditions on ManyToManyFields/CustomFields/... would not check the
       correct state of the Entity.
     - the actions would get incomplete sources of data (Relationships etc...)

    So, by running the Workflow after the view/forms have finished their job,
    we can check the final state of the entities as expected. The generic form
    views provided by Creme ('creme.creme_core.views.generic') "decorate" the
    'post()' method with the engine's context manager.
    For other views, the best is to run the engine jointly with an
    'atomic()' block which contains all your DB changes, in order to:
     - avoiding events which correspond to roll-backed DB changes.
     - leaving some DB changes not managed by the engine.

     Example:
         class MyView(...):
            def post(self, request, *args, **kwargs):
                [...]
                engine = WorkflowEngine.get_current():

                for entity in entities:
                    with atomic(), engine.run(user=request.user):
                        # Here you modify 'entity', create Relations/CremeProperties/etc...

                return HttpResponse()

    Note: working with an event queue which content is "captured" allows us to
    avoid cycle (when an Action generates some Events that also trigger a
    workflow, etc...). In a futur version, we can imagine to treat a limited
    number of "generations" (instead of just one currently).
    """
    class _WorkflowEngineContextmanager:
        """Internal Context manager class."""
        def __init__(self, engine: WorkflowEngine, user: CremeUser | None):
            self._engine = engine
            self._user = user
            self._start_index = len(engine._queue)

        def __enter__(self):
            pass

        def __exit__(self, exc_type, exc_value, tb):
            engine = self._engine
            events = engine._queue.pickup(start=self._start_index)

            if exc_type is None and events:
                logger.debug('WorkflowEngine: inspecting %s events', len(events))

                engine._is_executing_actions = True
                workflows = engine._workflows

                for event in events:
                    for workflow in workflows:
                        trigger = workflow.trigger
                        ctxt = trigger.activate(event)

                        if ctxt:
                            logger.debug(
                                'WorkflowEngine: trigger %s is activated (workflow id=%s), '
                                'inspecting its conditions...',
                                trigger, workflow.id,
                            )

                            if workflow.conditions.accept(
                                user=self._user, context=ctxt,
                                detect_change=trigger.conditions_detect_change,
                                use_or=trigger.conditions_use_or,
                            ):
                                actions = workflow.actions
                                logger.debug(
                                    'WorkflowEngine: conditions are filled, executing %s actions',
                                    len(actions),
                                )

                                for action in actions:
                                    logger.debug('WorkflowEngine: execute %s', action)

                                    try:
                                        action.execute(context=ctxt, user=self._user)
                                    except Exception:
                                        logger.exception('Error in the Workflow engine')

                # NB: we ensure all the events emitted by the actions are dropped
                #     So they won't trigger the engine during a potential other call.
                #     And so the engine can be safely run several times
                #     (e.g. in mass import job, each time a CSV line has been managed).
                engine._queue.pickup(start=self._start_index)

                engine._is_executing_actions = False  # TODO: test

    cache_key = 'creme_core-workflow_engine'

    _is_executing_actions = False

    _queue: WorkflowEventQueue
    _workflows: QuerySet  # QuerySet[Workflow]

    @classmethod
    def get_current(cls) -> WorkflowEngine:
        """Get the instance of engine corresponding to the current HTTP request.
        The instance is stored in the request cache (so we are sure to get a
        unique instance of engine for the request).
        """
        cache = get_per_request_cache()
        cache_key = cls.cache_key
        wf = cache.get(cache_key)
        if wf is None:
            from ..models import Workflow

            wf = cache[cache_key] = cls()
            wf._queue = WorkflowEventQueue()
            wf._workflows = Workflow.objects.filter(enabled=True)

        return wf

    def append_event(self, event: WorkflowEvent) -> WorkflowEngine:
        """Append a new event to the queue.
        See WorkflowEventQueue.append().
        @return Self to chain calls.
        """
        self._queue.append(event)
        return self

    @property
    def is_executing_actions(self):
        return self._is_executing_actions

    def run(self, user: CremeUser | None) -> _WorkflowEngineContextmanager:
        """Create a context manager which manages all events spawned dring its lifetime."""
        return self._WorkflowEngineContextmanager(self, user)


def run_workflow_engine(user: CremeUser | None) -> WorkflowEngine._WorkflowEngineContextmanager:
    """Helper function to use the context manager which run the Workflow engine."""
    return WorkflowEngine.get_current().run(user=user)


# Signal handlers --------------------------------------------------------------

# NB: post_save (not pre_save) => no event is pushed if an error happens during the save
@receiver(signals.post_save, dispatch_uid='creme_core-push_workflow_event_save')
def _push_event_for_save(sender, instance, created, **kwargs):
    """Fills the event queue."""
    if issubclass(sender, CremeEntity):
        WorkflowEngine.get_current().append_event(
            EntityCreated(entity=instance) if created else EntityEdited(entity=instance)
        )
    elif issubclass(sender, Relation):
        # TODO: should we only record the main side of the relationship as optimization?
        # NB: we check the pk to avoid duplicated event caused by double save()
        #     (reciprocal FKs)
        if created:
            WorkflowEngine.get_current().append_event(RelationAdded(relation=instance))
    elif issubclass(sender, CremeProperty):
        WorkflowEngine.get_current().append_event(PropertyAdded(creme_property=instance))


@receiver(signals.m2m_changed, dispatch_uid='creme_core-push_workflow_event_m2m')
def _push_event_for_m2m(sender, instance, action, **kwargs):
    # NB: actions are 'post_add', 'post_remove' & 'post_clear'
    #   - no event is pushed if an error happens during the save.
    #   - we avoid a de-duplication by not appending on 'pre_*' & 'post_*'.
    if isinstance(instance, CremeEntity) and action.startswith('post_'):
        WorkflowEngine.get_current().append_event(EntityEdited(entity=instance))
