======================================
Developer's notebook for Creme modules
======================================

:Author: Guillaume Englert
:Version: 09/10/2025 for Creme 2.8
:Copyright: Hybird
:License: GNU FREE DOCUMENTATION LICENSE version 1.3
:Errata: Hugo Smett, Patix, Morgane Alonso

.. contents:: Summary


Introduction
============

This document is addressed to people which want to add or modify some features
to the customer relationships management software Creme_. It's not an exhaustive
documentation of the Creme's API, it's a tutorial showing the creation of a module
module, step by step.


Requirements
============

- Get the bases of programming ; knowing the Python_ language would be nice.
- Knowing the HTML language a little.
- Knowing git_ or another version manager software.

Creme is developed with a Python framework for websites et Web apps : Django_.
If you really want to code some modules for Creme, you should know Django.
Its documentation is complete & quite good ; see here : https://docs.djangoproject.com/en/5.2/.
To begin, reading the `tutorial <https://docs.djangoproject.com/en/5.2/intro/overview/>`_
should be enough.

Creme uses the JavaScript (JS) library jQuery_ too ; to implement some features
of your modules, you may have to use some JS on client side (Web browser);
in these cases knowing jQuery would be a good thing. Nevertheless this is not
mandatory and we will mostly use example with no JS in this documentation.

.. _Creme: https://cremecrm.com
.. _Python: https://www.python.org
.. _git: https://git-scm.com
.. _Django: https://www.djangoproject.com
.. _jQuery: https://jquery.com

Management of a beavers' park
=============================

1. Presentation of the module
-----------------------------

The use case is: we want to create a module to manage a natural park with beavers.
We have to manage the population of beavers, and so having for all of them their
name, birthday, and also health.

A Creme module is an "app" in the Django's glossary. To be short, we'll use the
word "app" for our module.


2. First version of our module
------------------------------

Firstly you must have a working instance of Creme:

 - You have a *virtualenv* with an installed Creme 2.4 ;
   in this document we start from the principle that your *virtualenv*
   is activated (it's necessary to get the command ``creme``).
 - You have created a project (in this document we call it «my_project») with
   the command ``creme creme_start_project my_project``.
 - You have moved in the folder named ``my_project/`` (the parent one).
 - You have edited the file ``my_project/settings.py`` as you wish.
 - You have configured your RDBMS ; notice that when developing a module like
   here, using *SQLite* most of the time is alright (but test with RDBMS used in
   production before deploying the production of course).
 - You have created the data base (``creme migrate --settings=my_project.settings``),
   and filled it with the default data (``creme creme_populate --settings=my_project.settings``).
 - You have created the static media files
   (``creme generatemedia --settings=my_project.settings``).
 - You have configured your Web server ; the development server of Django is OK
   during the development step.

You can now run locally Creme without error with
``creme runserver --settings=my_project.settings``, log in and get the home page.


Configuration of the file ``local_settings.py``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As you have seen in the file fichier ``my_project/settings.py`` generated by the
command ``creme_start_project``, there are some values shared at project's level
(so all the instances, for the development or for the production), and some values
specific to an instance. For simplicity purpose, we consider here that you use
a file ``my_project/local_settings.py``. So in ``my_project/settings.py`` you
have a block of code like: ::

    try:
        from .local_settings import *  # NOQA
    except ImportError:
        pass


In order to get better information when errors happen, add this in
``my_project/local_settings.py``: ::

    DEBUG = True


You should not use the cache system of templates when you code, in order
to avoid re-starting the server for each template edition. In
``my_project/local_settings.py`` add: ::

    from .settings import TEMPLATES
    TEMPLATES[0]['OPTIONS']['loaders'] = (
        'django.template.loaders.app_directories.Loader',
        'django.template.loaders.filesystem.Loader',
    )

We also activate the **DEBUG** mode of th template engine : ::

    TEMPLATES[0]['OPTIONS']['debug'] = DEBUG


Additional tools
~~~~~~~~~~~~~~~~

The app `django extensions <https://github.com/django-extensions/django-extensions>`_
is interesting, it provides some useful commands (``runserver_plus``,
``shell_plus``, ``clean_pyc``, …).


Use of git
~~~~~~~~~~

It's strongly advised to version ``my_project/`` (with *git* here, but you can
use the tool you want of course) even in the case of *vanilla* deployment.
It's more true when you write some custom code. The complete use of *git* won't
be treated here, it's just a small introduction.

Init our repository: ::

    > cd my_project
    > git init


Let's check the status of our files with: ::

    > git status

The command prints in our terminal that there is no commit, and also the list of
non tracked files which looks like: ::

	.gitignore
	AGPL-3.0.txt
	README.md
	__init__.py
	media/
	settings.py
	setup.cfg
	setup.py


We create an initial commit corresponding to our working vanilla version: ::

    > git add .
    > git commit

The first command add all the files previously listed, the seconde one creates
the commit (do not forget to give a not empty message, like "Initial commit" for
example).

Each time you add a feature, vous should use the command ``git add my_new_file``
for each new file you want to track, then you can create a commit with: ::

    > git commit -a


Can van visualise the modifications done since the last commit with: ::

    > git diff


In order to back up your code, to allow collaborative working and to facilitate
deployments, you should get a repository on a centralised server (with service
like github.com/gitlab.com/… or auto-hosted).
At the end of your working session, you can save your work in your repository: ::

    > git push origin my_branch


**Hint** : when you want to upgrade the major version of Creme, you should work
in a branch so you can easily roll back to the previous version if you get issues.


Creation of the parent directory
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Move to our project, if it's not already done: ::

    > cd my_project

There is a command to create an app (``creme startapp``), nonetheless
this task is really easy, so we'er going to made this work ourselves for our
first app, step by step, in order to better understand what happens.
First, we create the directory containing our app: ::

    > mkdir beavers

Notice that, by convention (and for technical reason we'll see just after),
we use the plural form of the term "beaver".

Move to our new directory: ::

    > cd beavers

In order to the directory *beavers* is considered by Python as a module, we
must add a file named ``__init__.py`` (it can remain empty): ::

    > touch __init__.py


Creation of the first model
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now we create another directory, ``models/``, and move into it: ::

    > mkdir models
    > cd models


Then we create a file named ``beaver.py`` (notice the singular form) with our
favorite text editor, containing the following code: ::

    from django.db import models
    from django.utils.translation import gettext_lazy as _

    from creme.creme_core.models import CremeEntity


    class Beaver(CremeEntity):
        name = models.CharField(_('Name'), max_length=100)
        birthday = models.DateField(_('Birthday'))

        class Meta:
            app_label = 'beavers'
            verbose_name = _('Beaver')
            verbose_name_plural = _('Beavers')
            ordering = ('name',)

        def __str__(self):
            return self.name


We've just created our first model class, ``Beaver``. This model will correspond
to a table à une table dans notre DataBase Management System (DBMS) : *beavers_beaver*.
At the moment, we only store for each beaver its name and its birthday.
Our model inherits ``CremeEntity``, and not ``DjangoModel``: it means that our
beavers can have Properties, de Relationships, can be displayed in a list-view,
and use many more services.

In addition to the fields, we declare to:

- The class ``Meta`` which allows to indicate the name of the model's app for example.
- The method ``__str__`` used to display the ``Beavers`` objects prettily.


One again, to make the directory ``models/`` a module, we must put inside a
second file named ``__init__.py``, containing: ::

    from .beaver import Beaver


So, when Creme is starting, our model is automatically imported by Django, and
is linked to its table in the DBMS.


Install our module
~~~~~~~~~~~~~~~~~~

Edit the file ``my_project/settings.py`` by adding the line: ::

    INSTALLED_APPS.add('my_project.beavers')


**Remark** : we modify ``my_project/settings.py`` instead of
``my_project/local_settings.py`` because the list of installed apps in the project
should probably be shared between the teammates (developer, administrators).


Create the table in the database
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Run the following command suivante to generate the migration file: ::

    > creme makemigrations --settings=my_project.settings beavers


It will create a directory ``my_project//beavers/migrations/`` with 2 inner files
``__init__.py`` and ``0001_initial.py``. This last one indicates to Django the
description of the table which will contain our beavers.

Let's apply this migration: ::

    > creme migrate --settings=my_project.settings
    Operations to perform:
        Apply all migrations: beavers
    Running migrations:
        Rendering model states... DONE
        Applying beavers.0001_initial... OK

As you can see, a table "beavers_beaver" has been created. If you inspect it
(with sqlitebrowser or PHPMyAdmin for example), you'll see it has a column named
"name", with the type VARCHAR(100), and a column "birthday" with the type DATE.


Declare our app
~~~~~~~~~~~~~~~

First, we create a new file ``my_project/beavers/apps.py`` containing: ::

    from django.utils.translation import gettext_lazy as _

    from creme.creme_core.apps import CremeAppConfig


    class BeaversConfig(CremeAppConfig):
        default = True
        name = 'my_project.beavers'
        verbose_name = _('Beavers management')
        dependencies = ['creme.creme_core']

        def register_entity_models(self, creme_registry):
            from .models import Beaver

            creme_registry.register_entity_models(Beaver)



The singleton ``creme_registry`` stores the models inheriting ``CremeEntity``
(call to ``creme_registry.register_entity_models()``) if we want they dispose
of global search, configuration for buttons and blocs... It's generally the case
when we inherit ``CremeEntity``.

If we launch Creme with the Django's development server, and we log in
with our Web browser (to the address defined by SITE_DOMAIN in the
configuration), what happens? ::

    > creme runserver --settings=my_project.settings


There is no trace of our new app. But don't worry, we will fix it.


Our first view: the list view
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Our goal is now to display the list of beavers, corresponding to the URL
'/beavers/beavers'.

We add first a new directory ``views/`` in ``my_project/beavers/``, and its
usual file ``__init__.py``: ::

    > mkdir views
    > cd views
    > touch __init__.py


In ``views/``, we create the file ``beaver.py`` like: ::

    from creme.creme_core.views import generic

    from ..models import Beaver


    class BeaversList(generic.EntitiesList):
        model = Beaver


We must now link this view to its URL. Take a look to the file ``creme/urls.py`` ;
we find the configuration of base paths for each app. We can see that for each
Creme app in the list INSTALLED_APPS, the code imports the file ``urls.py`` in
the directory ``name_of_your_app/``.

So we do not have to modify ``creme/urls.py`` and we just create the file
``urls.py`` in ``my_project/beavers/``: ::

    from django.urls import re_path

    from .views import beaver

    urlpatterns = [
        re_path(r'^beavers[/]?$', beaver.BeaversList.as_view(), name='beavers__list_beavers'),
    ]

Notice that :

 - the last parameter of ``re_path()``, which gives a name to our URL. The
   convention of Creme is 'my_app' + '__list_' + 'my_models' for the list view.
 - the final '/' of our URL which is optional (it's the general policy for URLs
   in Creme).

Finally we add the method ``get_lv_absolute_url()`` in our model. This method
will make possible to return to the bevaars' list when we delete a beaver, for
example: ::

    [...]

    from django.urls import reverse


    class Beaver(CremeEntity):
        [...]

        @staticmethod
        def get_lv_absolute_url():
            return reverse('beavers__list_beavers')


**Note** : the method ``reverse()``, which permit to find a URL by the name
given to the function ``re_path()`` used in our ``urls.py``.

We can now reach the list from our browser by typing it in the address bar…
well almost. Indeed Creme asks us to create a view-of-list. When it's done,
we get our beavers' list… and its empty. Of course, no beaver has been created
yet.


The creation view
~~~~~~~~~~~~~~~~~

Create a directory ``my_project/beavers/forms``, with the usual ``__init__.py``: ::

    > mkdir forms
    > cd forms
    > touch __init__.py


In ``forms/``, we create then the file ``beaver.py``: ::

    from django.utils.translation import gettext_lazy as _

    from creme.creme_core.forms import CremeEntityForm

    from ..models import Beaver


    class BeaverForm(CremeEntityForm):
        class Meta(CremeEntityForm.Meta):
            model = Beaver


It's a simple form related to our model.

**Note** : most of creation views for entities which you find in the base apps
provided by Creme do not use a regular Django's form. They use the CustomForm
system of Creme instead, which allows teh users to configure the fields
themselves. CustomForms are explained later, and we will use in a first time
the regular forms, to be simpler.

Then we edit ``views/beaver.py``, by adding the following lines at the end (you
can move the ``import`` at the beginning of tye file, with other ``import``,
of course): ::

    from ..forms.beaver import BeaverForm

    class BeaverCreation(generic.EntityCreation):
        model = Beaver
        form_class = BeaverForm


We add the entry referencing ``beaver.BeaverCreation`` in ``beavers/urls.py``: ::

    urlpatterns = [
        re_path(r'^beavers[/]?$',    beaver.BeaversList.as_view(),    name='beavers__list_beavers'),
        re_path(r'^beaver/add[/]?$', beaver.BeaverCreation.as_view(), name='beavers__create_beaver'),
    ]


It remains a method ``get_create_absolute_url()`` to add in our model, and
the attributes ``creation_label`` and ``save_label``, which allows to name
correctly some interface elements (button, menu etc…): ::

    class Beaver(CremeEntity):
        [...]

        creation_label = _('Create a beaver')  # Label of tyhe creation form
        save_label	   = _('Save the beaver')  # Label of the save button

        [...]

        @staticmethod
        def get_create_absolute_url():
            return reverse('beavers__create_beaver')


If we reload our list view, a button 'Create a beaver' has appeared. When we
click it, we get the expected form. But when we submit our form (without
validation error), we get a error 500.
No panic: the class view ``EntityCreation`` just tried to display the detailed
view for our created castor. It has been created, but the view does not exist yet.


The detailed view
~~~~~~~~~~~~~~~~~

Add this class view (in ``views/beaver.py`` as seen previously): ::

    class BeaverDetail(generic.EntityDetail):
        model = Beaver
        pk_url_kwarg = 'beaver_id'


Edit ``beavers/urls.py`` to add this URL: ::

    urlpatterns = [
        re_path(r'^beavers[/]?$',                   beaver.BeaversList.as_view(),    name='beavers__list_beavers'),
        re_path(r'^beaver/add[/]?$',                beaver.BeaverCreation.as_view(), name='beavers__create_beaver'),
        re_path(r'^beaver/(?P<beaver_id>\d+)[/]?$', beaver.BeaverDetail.as_view(),   name='beavers__view_beaver'),  # < -- NEW
    ]

If we refresh our page in the browser, we get the detailed views as expected.

**Note** : the icon of our entity does not work at the moment ; don't worry, it
will be fixed soon.

In order the next creations of beaver do not lead to error 404, we create the
method ``get_absolute_url()``: ::

    [...]


    class Beaver(CremeEntity):
        [...]

        def get_absolute_url(self):
            return reverse('beavers__view_beaver', args=(self.id,))


The edition view
~~~~~~~~~~~~~~~~

Currently, ours beavers cannot be edited yet (with the big pen we can see in
the detailed views).

Add this class view in ``views/beaver.py``: ::

    class BeaverEdition(generic.EntityEdition):
        model = Beaver
        form_class = BeaverForm
        pk_url_kwarg = 'beaver_id'


Add the related URL: ::

    urlpatterns = [
        re_path(r'^beavers[/]?$',                        beaver.BeaversList.as_view(),    name='beavers__list_beavers'),
        re_path(r'^beaver/add[/]?$',                     beaver.BeaverCreation.as_view(), name='beavers__create_beaver'),
        re_path(r'^beaver/edit/(?P<beaver_id>\d+)[/]?$', beaver.BeaverEdition.as_view(),  name='beavers__edit_beaver'),  # < -- NEW
        re_path(r'^beaver/(?P<beaver_id>\d+)[/]?$',      beaver.BeaverDetail.as_view(),   name='beavers__view_beaver'),
    ]


And the method ``get_edit_absolute_url``: ::

    [...]


    class Beaver(CremeEntity):
        [...]

        def get_edit_absolute_url(self):
            return reverse('beavers__edit_beaver', args=(self.id,))


The deletion view
~~~~~~~~~~~~~~~~~

Currently, when you go a a beaver's detailed view, there is no button which
allows to delete it as in the other types of entity, like Contacts for example.

Indeed, beavers cannot be deleted yet; in some cases that's what you'll want.
But generally, you want to have the possibility to delete some entities. Edit
your file ``my_project/beavers/apps.py`` : ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_deletors(self, entity_deletor_registry):
            from .models import Beaver

            entity_deletor_registry.register(model=Beaver)


The deletion button is now visible on your vue detailed view, and also on the
list view.

**Going further** : the deletion will currently behave as for the other types of
entity, and will principally check the deletion credentials of the user. In some
cases you want to customise the deletion, notably to add some additional checks
which avoid some entities to be deleted, or to be deleted by some users.

Create a file ``my_project/beavers/deletors.py`` : ::

    from django.utils.translation import gettext as _

    from creme.creme_core.core.deletion import EntityDeletor
    from creme.creme_core.core.exceptions import ConflictError


    class BeaverDeletor(EntityDeletor):
        def check_permissions(self, *, user, entity):
            # We call the super-method to be sure the base checks are made...
            super().check_permissions(user=user, entity=entity)

            # ...and we add some rules.
            # "entity" is a Beaver instance
            # "user" is the user who tries to delete
            if entity.name == 'Betty':
                raise ConflictError(_('Hey you cannot delete Betty!'))

We just have now to indicate which behaviour to use during the deletion of a
beaver, in ``my_project/beavers/apps.py`` : ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_deletors(self, entity_deletor_registry):
            from .models import Beaver
            from . import deletors

            entity_deletor_registry.register(
                model=Beaver, deletor_class=deletors.BeaverDeletor,
            )


Add entries in the menu
~~~~~~~~~~~~~~~~~~~~~~~

We declare 2 menu entries (one for the list view, one for the creation view),
in a new file ``my_project/beavers/menu.py``: ::

    from creme.creme_core.gui import menu

    from .models import Beaver


    class BeaversEntry(menu.ListviewEntry):
        id = 'beavers-beavers'
        model = Beaver


    class BeaverCreationEntry(menu.CreationEntry):
        id = 'beavers-create_beaver'
        model = Beaver

**Note** : we have prefixed the attributes ``id`` with pour app's name ; it's
a technic which will be regularly used, in order to avoid identifiers collisions
between the different apps.

In our file ``apps.py``, we add the method ``BeaversConfig.register_menu_entries()``
pour register our 2 new classes: ::


    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_menu_entries(self, menu_registry):
            from . import menu

            menu_registry.register(
                menu.BeaversEntry,
                menu.BeaverCreationEntry,
            )



Currently the menu does not display our new entries ; Creme knows only that they
are valid entries. You have to go the configuration UI for the menu (in the menu
"gear" > Menu ), and use our new entries.
For example, we can modify the container "Directory" ; the entry for list of
beavers is now proposed when we click on the button
«Add regular entries». In the next chapter, we'll see how to add our entries
during the DB setup, to avoid doing it manually.

**Going further** : we add then an entry in the window which can create all
types of entity (in the menu "+ Creation" > Other type of entity).
In our file ``apps.py``, we add a method once again: ::

    [...]

    def register_creation_menu(self, creation_menu_registry):
        from .models import Beaver

        creation_menu_registry.get_or_create_group(
            'persons-directory', _('Directory'), priority=10,
        ).add_link(
            'beavers-create_beaver', Beaver, priority=20,
        )


In this example, we insert our entry in the group "Directory" (used by the app
``persons`` too) ; we retrieve it with ``get_or_create_group()``.
To display the groups' structure of this window, you write
``print(creation_menu_registry.verbose_str)``.


Module initialisation
~~~~~~~~~~~~~~~~~~~~~

The majority of the modules expect some data exist in the data base, in order
to work correctly, or just to be more user friendly. For example, the first
time we displayed the beavers list-view, we had to create a view-of-list
(named HeaderFilter in Creme's code, and containing columns to display in the list) ;
we had to configure the menu too. We're going to write some code run at deployment,
which create this view of list, and the menu entries.

Let's create the file ``my_project/beavers/constants.py``, which contains some
constants of course: ::

    # NB: this will be the identifier of or default HeaderFilter. To avoid
    #     collisions between apps, the convention is to build a value with
    #     the shape 'my_app' + 'hf_' + 'my_model'.
    DEFAULT_HFILTER_BEAVER = 'beavers-hf_beaver'


Then we create a file : ``my_project/beavers/populate.py``. ::

    from django.utils.translation import gettext as _

    from creme.creme_core.core.entity_cell import EntityCellRegularField
    from creme.creme_core.gui.menu import ContainerEntry
    from creme.creme_core.management.commands.creme_populate import BasePopulator
    from creme.creme_core.models import (
        HeaderFilter,
        MenuConfigItem,
        SearchConfigItem,
    )

    from . import constants
    from .menu import BeaversEntry
    from .models import Beaver


    class Populator(BasePopulator):
        dependencies = ['creme_core', 'persons']

        # The base class uses this attribute to build HeaderFilter instances
        # (see method '_populate_header_filters()')
        HEADER_FILTERS = [
            # By default the instances are marqued as <is_custom=False>; it
            # allows to get default HeaderFilters which can be deleted.
            # The parent class classe will create the instance only if does not
            # exist yet (using l'ID), so don't worry the command can be run again.
            HeaderFilter.objects.proxy(
                id=constants.DEFAULT_HFILTER_BEAVER,
                name=_('Beaver view'),
                model=Beaver,
                cells=[
                    (EntityCellRegularField, 'name'),
                    (EntityCellRegularField, 'birthday'),
                ],
            ),
        ]
        # The base class uses this attribute to build SearchConfigItem instances
        # (see method '_populate_search_config()')
        SEARCH = [
            SearchConfigItem.objects.builder(model=Beaver, fields=['name']),
        ]

        # This method allow to know if the command has already be run for our app.
        # You MUST implement it.
        def _already_populated(self):
            return HeaderFilter.objects.filter(
                pk=constants.DEFAULT_HFILTER_BEAVER,
            ).exists()

        # This method is only called the first time the command is run for this app.
        def _populate_menu_config(self):
            directory = MenuConfigItem.objects.filter(
                entry_id=ContainerEntry.id,
                entry_data={'label': _('Directory')},
            ).first()

            if directory is not None:
                MenuConfigItem.objects.create(
                    entry_id=BeaversEntry.id, order=50, parent=directory,
                )


Additional explanations :

- we create a ``HeaderFilter`` with 2 columns, simply corresponding
  to the name et the birthday of our beavers. The class
  ``EntityCellRegularField`` corresponds to classical fields in the Beaver
  model (there are other classes, like ``EntityCellRelation`` for example).
- The instance of ``SearchConfigItem`` we create corresponds to the default
  configuration of the the global search; this one will use the field 'name'
  for beavers.
- We add a menu entry in the section "Directory", normally created by the app
  ``persons`` (that's why we add this app as dependency, with the attribute
  ``dependencies``). We create this entry only if no entry corresponding to our
  app already exists in data base (it's a perfectible way to try not to modify the
  menu after the first run of the command…).

The code is run by the command ``creme_populate``. It 'populates' the data base
for our app. In ``creme/``, run: ::

    > python creme/manage.py creme_populate beavers


When we display our beavers' list again, the second HeaderFilter is present.

**Going further**: we improve now our beaver list-view to insure that when an
user logs in with a new session, the default HeaderFilter vue is used (without
this improvement the first HeaderFilter by alphabetical oder is used): ::

    [...]
    from .. import constants  # <- NEW

    [...]

    class BeaversList(generic.EntitiesList):
        model = Beaver
        default_headerfilter_id = constants.DEFAULT_HFILTER_BEAVER  # <- NEW


Icons management
~~~~~~~~~~~~~~~~

The icon system fetch in the images of the current theme, using the given name
and adding the size adapted to the context.

Creme is released with the icons for its included apps. For example, for the
theme "icecream", in the directory ``creme/static/icecream/images`` you find a
file "alert_22.png" ; its icon name is "alert" (this name is used, for example,
by some *templatetags*), and the le suffix "_22" indicates its width of
22 x 22 pixels.

You can add your own icons in ``creme/beavers/static/THEME/images/`` ;
(replace THEME with the name of the theme, "icecream" or "chantilly" for base
themes). Do not forget to run the command ``generatemedia`` when you add images.

In addition to explicitly named icons, Creme permit to automatically links an
icon to an entity type. Let's add a method in our file ``beavers/apps.py``: ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_icons(self, icon_registry):
            from .models import Beaver

            icon_registry.register(Beaver, 'images/contact_%(size)s.png')


Here we use the Contacts' icon which is provided by default ; you could use a
more specific icon of course.


Localisation (l10n)
~~~~~~~~~~~~~~~~~~~

Until now we've only used labels in english. Even if your browser is configured
to retrieve pages in french (for example) whenever it's possible, the interface
of the module *beavers* remains in english. But we've always used the functions
``gettext`` and ``gettext_lazy`` (imported as '_') to wrap our labels. So it
will be easy to localise our module.
In ``my_project/beavers/``, create a sub directory ``locale``, then run the
command which builds the translation file (in french here): ::

    > mkdir locale
    > creme makemessages --settings=my_project.settings -l fr --no-location
    processing language fr


A file is created by the command (and the needed directories too) :
``locale/fr/LC_MESSAGES/django.po``

The file ``django.po`` looks like (dates will be different of course): ::

    # SOME DESCRIPTIVE TITLE.
    # Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
    # This file is distributed under the same license as the PACKAGE package.
    # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
    #
    #, fuzzy
    msgid ""
    msgstr ""
    "Project-Id-Version: PACKAGE VERSION\n"
    "Report-Msgid-Bugs-To: \n"
    "POT-Creation-Date: 2023-02-03 11:10+0100\n"
    "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
    "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
    "Language-Team: LANGUAGE <LL@li.org>\n"
    "MIME-Version: 1.0\n"
    "Content-Type: text/plain; charset=UTF-8\n"
    "Content-Transfer-Encoding: 8bit\n"
    "Plural-Forms: nplurals=2; plural=(n > 1);\n"

    msgid "Beavers management"
    msgstr ""

    msgid "Create a beaver"
    msgstr ""

    msgid "Beaver view"
    msgstr ""

    msgid "Name"
    msgstr ""

    msgid "Birthday"
    msgstr ""

    msgid "Beaver"
    msgstr ""

    msgid "Beavers"
    msgstr ""

    msgid "Directory"
    msgstr ""

    msgid "Save the beaver"
    msgstr ""

Edit this file by filling the translations in strings "msgstr": ::

    # FR LOCALISATION OF 'BEAVERS' APP
    # Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
    # This file is distributed under the same license as the PACKAGE package.
    # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
    #
    msgid ""
    msgstr ""
    "Project-Id-Version: PACKAGE VERSION\n"
    "Report-Msgid-Bugs-To: \n"
    "POT-Creation-Date: 2023-02-03 11:10+0100\n"
    "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
    "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
    "Language-Team: LANGUAGE <LL@li.org>\n"
    "Language: fr\n"
    "MIME-Version: 1.0\n"
    "Content-Type: text/plain; charset=UTF-8\n"
    "Content-Transfer-Encoding: 8bit\n"
    "Plural-Forms: nplurals=2; plural=n>1;\n"

    msgid "Beavers management"
    msgstr "Gestion des castors"

    msgid "Create a beaver"
    msgstr "Créer un castor"

    msgid "Beaver view"
    msgstr "Vue de castor"

    msgid "Name"
    msgstr "Nom"

    msgid "Birthday"
    msgstr "Anniversaire"

    msgid "Beaver"
    msgstr "Castor"

    msgid "Beavers"
    msgstr "Castors"

    msgid "Directory"
    msgstr "Annuaire"

    msgid "Save the beaver"
    msgstr "Sauvegarder le castor"

Now, you just have to compile our translation file with the following command: ::

    > creme compilemessages --settings=my_project.settings
    processing file django.po in [...]beavers/locale/fr/LC_MESSAGES

The file ``my_project/beavers/locale/fr/LC_MESSAGES/django.mo`` has been generated.
If you re-start the Web server, the labels are now in french, if your browser and
your user are configured to use french ; the middleware
'django.middleware.locale.LocaleMiddleware' must be in the settings too
(it's the default configuration).


3. Advanced principles
----------------------

Use of creme_config
~~~~~~~~~~~~~~~~~~~

Imagine we want to store the health of each castor : it could be used, for
example, by the list-view to only display sick beavers, and call a veterinary
if it's needed.

Create a file ``my_project/beavers/models/status.py``: ::

    from django.db import models
    from django.utils.translation import gettext_lazy as _, pgettext_lazy

    from creme.creme_core.models import MinionModel


    class Status(MinionModel):
        name = models.CharField(_('Name'), max_length=100, unique=True)

        creation_label = pgettext_lazy('beavers-status', 'Create a status')

        def __str__(self):
            return self.name

        class Meta:
            app_label = 'beavers'
            verbose_name = _('Beaver status')
            verbose_name_plural = _('Beaver statuses')
            ordering = ('name',)


**Note** : we used the abstract parent class ``MinionModel`` which is made for
this kind of model which will be visible and configurable by users. It notably
contains the fields ``uuid`` and ``is_custom`` (more explanations on them below).

**Note** : we gave a default order (attribute ``ordering`` of the class ``Meta``)
which is user friendly;  this order is used, for example, by forms (if you do
not explicitly give another one, of course).

**Note** : we used the translation function ``pgettext_lazy()`` which takes
a context parameter. It's to avoid possible collisions with strings in other
apps. The term "status" being unclear, it could be used by other apps, and
we can imagine that in some languages (or customised translations), the
translation can be different depending on the case.
In Creme, we use contexts with prefix 'app_name-'.

Edit ``models/__init__.py``: ::

    from .beaver import Beaver
    from .status import Status  # <-- NEW


Let's generate a first migration which creates the corresponding table: ::

    > creme makemigrations --settings=my_project.settings beavers

A file named ``my_project/beavers/migrations/0002_status.py`` appears.

As we want to add a not nullable *ForeignKey* in our class ``Beaver`` (because
it's make the example more interesting), we create now a data migration
(previously we create schema migration) which adds in DB an instance of
``Status`` ; this instance will be used as default value by existing instances
of Beavers. It's a common use case : a production version you'll have to
upgrade without breaking existing data.

Let's create this migration (notice the parameter ``empty``): ::

    > creme makemigrations --settings=my_project.settings beavers --empty

A file named from te current date has just ben created. Rename it
``0003_populate_default_status.py``, then open it in your editor.
It should look like this: ::

    from django.db import migrations, models


    class Migration(migrations.Migration):

        dependencies = [
            ('beavers', '0002_status'),
        ]

        operations = [
        ]


Edit it to get: ::

    from django.db import migrations, models

    def populate_status(apps, schema_editor):
        apps.get_model('beavers', 'Status').objects.create(id=1, name='Healthy', is_custom=False)


    class Migration(migrations.Migration):
        dependencies = [
            ('beavers', '0002_status'),
        ]

        operations = [
            migrations.RunPython(populate_status),
        ]


Then add a field 'status' in our model ``Beaver``: ::

    from django.db import models
    from django.urls import reverse
    from django.utils.translation import gettext_lazy as _

    from creme.creme_core.models import CremeEntity, CREME_REPLACE  # <- NEW

    from .status import Status  # <- NEW


    class Beaver(CremeEntity):
        name = models.CharField(_('Name'), max_length=100)
        birthday = models.DateField(_('Birthday'))
        status = models.ForeignKey(
            Status, verbose_name=_('Status'), on_delete=CREME_REPLACE,
        )  # <- NEW

        [....]


**Remark** : we use a special Creme value for the attribute ``on_delete`` :
``CREME_REPLACE``. This value is equivalent to the classical Django's
``PROTECT``, but in the configuration interface, if you delete a status value,
Creme will propose to replace this value in the instances of ``Beaver`` which
use it.

- There is too ``CREME_REPLACE_NULL`` which is equivalent to ``SET_NULL`` and
  will propose also a choice ``null`` for the concerned ``ForeignKey``.
- The classical values (``PROTECT``, ``SET_NULL`` …) work of course.

We now have to create the corresponding migration (no ``empty`` parameter since
it's a schema migration): ::

    > creme makemigrations --settings=my_project.settings beavers
    You are trying to add a non-nullable field 'status' to beaver without a default; we can't do that (the database needs something to populate existing rows).
    Please select a fix:
    1) Provide a one-off default now (will be set on all existing rows)
    2) Quit, and let me add a default in models.py
    Select an option:

We anticipated this question, and so we can choose the option 1, then give the
default value "1" (because it's the ID of the ``Status`` created in the
previous migration).

We can now run our migrations: ::

    > creme migrate --settings=my_project.settings

By re-starting the server, when we add a beaver, we get a new field in the form
as expected. But only one choice of ``Status`` is available, it's not very useful.

First, we are going to improve our ``populate.py``, by creating some status at
deployment. So the users will get immediately several choices os status. In the
file ``beavers/constants.py``, we add some constants: ::

    [...]

    # We used the function 'uuid.uuid4()' in a python shell to generate this values
    UUID_STATUS_HEALTHY = '3fdcc650-b34a-40ba-a376-926bec866d5e'
    UUID_STATUS_SICK = 'dc7d6762-7a38-40b6-8c83-e7b4092e6808'


We use these constants right now ; edit ``populate.py``: ::

    [...]
    from . import constants
    from .models import Beaver, Status

    class Populator(BasePopulator):
        [...]

        # Notice that we create instances WITHOUT saving them;
        # '_save_minions()' will decide to call 'save()' (or not).
        STATUSES = [
            # These 2 statuses are marked as <is_custom=False> :
            #  - users cannot delete them.
            #  - they must always exist (so they will be created if they are not
            #    found in data-base when we populate it).
            Status(
                uuid=constants.UUID_STATUS_HEALTHY,
                name=_('Healthy'),
                is_custom=False,
            ),
            Status(
                uuid=constants.UUID_STATUS_SICK,
                name=_('Sick'),
                is_custom=False,
            ),
            # This status is marked as <is_custom=True> and so '_save_minions()'
            # will only create it during the first run of the command.
            Status(
                uuid='c2649a86-9019-4bf4-9f59-deb33b16ae4e',
                name=_('Fluffy'),
                is_custom=True,
            ),
        ]

        def _populate_statuses(self):
            self._save_minions(self.STATUSES)

        def _populate(self):
            super()._populate()
            # The method '_populate_statuses()' is not defined by the parent
            # class; we have to call it explicitly.
            self._populate_statuses()


Using  UUIDs for our ``Status`` has several virtues. In this document, we'll use
them to retrieve easily the instances in the data-base.

Run the command again: ::

    > creme creme_populate --settings=my_project.settings beavers


The creation form for Beaver propose these 2 new status.

The last thing is to indicate to Creme to manage this model in its
configuration. Once again, we have to add a method to our file
``beavers/apps.py``: ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_creme_config(self, config_registry):
            from . import models

            config_registry.register_model(models.Status)


If you go to 'General configuration' portal, in the
'Applications portals', the section 'Beavers configuration portal' has
appeared: it allows us to create new ``Status`` as expected.

**Going further** : you can specify the forms to use to create or edit status
if the ones which are automatically generated are not adapted. I could happen
with a business rule which cannot be described with regular model constraints
(like ``nullable``): ::

    [...]

    config_registry.register_model(
        models.Status,
    ).creation(
        form_class=MyStatusCreationForm,
    ).edition(
        form_class=MyStatusEditionForm,
    )


You can customize the creation/edition URLs too (argument
"url_name" of the methods ``creation()/edition()``), and also the brick
which manage this model (method ``brick_class()``).

**A bit further** : if you want the **users can choose the order** of the
statuses (in forms, in list-views quick-search etc…), you have to add a field
``order`` like that: ::

    [...]

    from creme.creme_core.models import CremeModel
    from creme.creme_core.models.fields import BasicAutoField  # <- NEW


    class Status(CremeModel):
        name = models.CharField(_('Name'), max_length=100, unique=True)
        is_custom = models.BooleanField(default=True).set_tags(viewable=False)
        order = BasicAutoField()  # <- NEW

        [...]

        class Meta:
            app_label = 'beavers'
            verbose_name = _('Beaver status')
            verbose_name_plural  = _('Beaver status')
            ordering = ('order',)  # <- NEW


Notice that a ``BasicAutoField`` is not editable and not visible by default,
and it manages automatically its incrementation, so you should normally don't have
to mind about this field.


Make our model appear in the quick search as best result
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We previously configured the fields to use when searching in our instances of
Beaver ; so when we launch a global search (up-right corner in the menu bar),
and we go in «All results», the found beavers (if there are some) are in a
result bloc.

If you want beavers to appear more often in the quick results (the list of
results displayed in real-time when you enter text in the search field) as best
result, you must set a high valer to the attribute ``search_score`` of your
model ``Beaver``. In Creme, by default, the model ``Contact`` gets a value of
101. So if you set a higher score, when a searched string is found in (at
least) one contact and one beaver, the beaver will be privileged, and it will
appear as best result: ::

    [...]

    class Beaver(CremeEntity):
        [...]

        search_score = 200


New types of relationship
~~~~~~~~~~~~~~~~~~~~~~~~~

Of course, you can create new types of relationship with the configuration
interface (Menu > Configuration > Types of relationship), then use them to link
some entities, filter in list-views, create some bricks related to this type…

If we want some types to be available just after the deplaoyment, the good way
is to create them in our script ``beavers/populate.py``. We are going to create
a type of relationship linking a veterinary (contact) and a beaver ; indeed we
create 2 types which are symmetrical : «the beaver gets as veterinary» et
«the veterinary takes care of the beaver».

First, we edit ``beavers/constants.py`` to add the 2 primary key: ::

    [...]

    REL_SUB_HAS_VET = 'beavers-subject_has_veterinary'
    REL_OBJ_HAS_VET = 'beavers-object_has_veterinary'


**Important** : your keys must follow this rules :

 - Starting by the name of your app, in order to avoid collision with types
   defined by other apps.
 - Then, one of the 2 keys must continue with '-subject_', and the other
   '-object_', so the configuration can distinguish the main meaning from the
   second one.
 - At the end, there is an arbitrary string (ideally it "describes" the type),
   which should be identical in the 2 symmetrical types, for consistency reason.

Then ``beavers/populate.py``: ::

    [...]
    from creme.creme_core.models import RelationType

    [...]
    from creme import persons

    [...]
    Contact = persons.get_contact_model()


    class Populator(BasePopulator):
        [...]

        # This attribute is defined in BasePopulator & is used automatically
        RELATION_TYPES = [
            RelationType.objects.builder(
                id=constants.REL_SUB_HAS_VET,
                predicate=_('has veterinary'),
                models=[Beaver],
            ).symmetric(
                id=constants.REL_OBJ_HAS_VET,
                predicate=_('is the veterinary of'),
                models=[Contact],
            ),
        ]


**Notes** : we set constraints on entity types which can link (Beaver and
Contact here). We could also, if we'd create a property type «is a veterinary»
(for Contacts), set an additional constraint: ::

        PROPERTY_TYPES = [
            CremePropertyType.objects.proxy(
                 uuid=constants.UUID_PROP_VETERINARY,
                 app_label='my_app',
                 text=_('is a veterinary'),
                 subject_models=[Contact],
            ),
        ]
        RELATION_TYPES = [
            RelationType.objects.builder(
                [...]
            ).symmetric(
                [...]
                properties=[constants.UUID_PROP_VETERINARY],
            ),
        ]

The created types of relationship cannot be deleted from the configuration UI
(the argument ``is_custom`` of ``RelationType.objects.builder()`` is ``False``
by default), which is generally a good thing.

**Going a bit further** : in some cases, we want to control precisely the
creation and the deletion of the relationships with a given type, because of
some business logic. For example, one the entities to link must have a
particular value in a field, or only some users are allowed to delete these
relationships. The solution is to declare these types as internal ;
the generic creation and deletion views for relationships ignore these kind of
types: ::

        RelationType.objects.builder(
            [...],
            is_internal=True,
        ).symmetric([...])

So you have to write the creation and deletion codes for these types.
Typically, for the creation, we create the relationship in the creation form
of an entity fiche (e.g. we assign a veterinary during the beaver creation), or
in a specific view (e.g. a brick which displays related veterinaries, and which
allow to add/remove ones).


Using bricks
~~~~~~~~~~~~

*This is a simple introduction. Bricks are a big part of Creme and explaining
all their details would need a complete document.*

Some general explanations
*************************

**Configurability** : if your brick is intended to be displayed on a detailed
view or on home views, the brick should be configurable. It means that in the
bricks configuration (Menu > Configuration > Blocks), the users can define the
presence and the position of your brick. So, this one must provides some
information to configuration UI, like its name or on which types de fiche the
brick can be displayed on (about detailed views). If your brick is displayed on
a specific view, this one will provide the list of bricks to use ; so the list
will be defined by the code (unless you code customised configuration system
for this view, of course).

**Reloading view** : when a change happens in a brick (e.g. the user opened from
this brick a *popup* and did a modification), this brick is reloaded, without
reloading the whole page. If you use a generic view (detailed view or home),
Creme set automatically the reloading URL (it is stored in HTML), which
corresponds to an existing view ; so you have nothing to do. But if you code a
specifi view with some bricks, you could have to code your own reloading view
(if the ones provided by creme_core are not sufficient), and you'll have to
inject the URL in the template context of your page.

**Dependencies** : when a brick is reloaded, there are often other bricks to
reload in order to keep the page consistent (e.g. when we add a product line in
an invoice, we reload the total brick too). Creme uses a dependencies system,
which is easy to use by developers, and which give good results.
Each brick declares a list of dependencies. When a brick must be reloaded, all
bricks in the page are inspected, and all briks which have at least one
dependence in common are reloaded too. Most of the time, the dependencies are
given as a list of model (e.g. Contact, Organisation) ; these models the ones
containing the data displayed by the brick. But in some more complex use cases
it's possible to generate more clever dependencies.

Example: simple brick in detailed view
**************************************

We going to code a simple brick displaying the birthday and the age of a beaver.
Notice that in the section `Function fields`_ we write a function field which
does the same thing (for the age), but in a re-usable way, notably in a custom
brick ; so it's globally a better way.

Create the file ``my_project/beavers/bricks.py``: ::

    from datetime import date

    from django.utils.translation import gettext_lazy as _

    from creme.creme_core.gui.bricks import Brick

    from .models import Beaver


    class BeaverAgeBrick(Brick):
        # ID is used :
        #  - by the configuration to store the position of the brick.
        #  - by the reloading system, to know which brick have to be re-rendered & sent.
        # Once again, we use the app name to guaranty uniqueness.
        id = Brick.generate_id('beavers', 'beaver_age')

        # This brick displays data from beavers, so if the data of a beaver are modified by
        # another brick (notably if the birthday is edited) so we want to reload this brick
        # in order its render is up-to-date.
        dependencies = (Beaver,)

        # We create this template just after.
        template_name = 'beavers/bricks/age.html'

        # Name used by the configuration UI to designate this brick.
        verbose_name = _('Age of the beaver')

        # The configuration UI will only propose to set this brick on the beavers's detailed view
        # (NB: do not set this attribute in order to the brick can be displayed on all
        # entity types)
        target_ctypes = (Beaver,)

        # If we define this method, we indicate that the block can be displayed on detailed views
        # (another method is used for home: 'home_display()').
        def detailview_display(self, context):
            # The current entity is injected in the context by the view 'generic.EntityDetail'
            # & by the reloading view 'bricks.DetailviewBricksReloading'.
            beaver = context['object']

            birthday = beaver.birthday

            return self._render(self.get_template_context(
                context,
                age=(date.today().year - birthday.year) if birthday else None,
            ))

Now we add the corresponding template,
``my_project/beavers/templates/beavers/bricks/age.html``: ::

    {% extends 'creme_core/bricks/base/table.html' %}
    {% load i18n creme_bricks %}

    {% comment %}
        The CSS class "beavers-age-brick" is not indispensable, it just permits
        to modify more easily the look of the brick with a CSS file.
    {% endcomment %}
    {% block brick_extra_class %}{{block.super}} beavers-age-brick{% endblock %}

    {% block brick_header_title %}
        {% brick_header_title title=_('Age') %}
    {% endblock %}

    {# On ne met pas de titre à nos colonnes #}
    {% block brick_table_head %}{% endblock %}

    {# Content: we are in a brick with type 'table', so we use <tr>/<td> #}
    {% block brick_table_rows %}
        <tr>
            <td>
                <h1 class="beavers-birthday beavers-birthday-label">{% translate 'Birthday' %}</h1>
            </td>
            <td data-type="date">
                <h1 class="beavers-birthday beavers-birthday-value">{{object.birthday}}</h1>
            </td>
        </tr>
        <tr>
            <td>
                <h1 class="beavers-age beavers-age-label">{% translate 'Age' %}</h1>
            </td>
            <td>
                <h1 class="beavers-age beavers-age-value">
                  {% if not age %}
                    —
                  {% else %}
                    {% blocktranslate count year=age %}{{year}} year{% plural %}{{year}} years{% endblocktranslate %}
                  {% endif %}
                </h1>
            </td>
        </tr>
    {% endblock %}

In order our brick class is used by Creme, we must register it with ``beavers/apps.py``: ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_bricks(self, brick_registry):
            from . import bricks

            brick_registry.register(bricks.BeaverAgeBrick)

Now the brick is available in the configuration UI of bricks, when we create
or edit a configuration of beavers' detailed view.

If we want the brick to be present in the default configuration (i.e. at
deployment), we have to improve our file ``beavers/populate.py``: ::

    [...]
    import creme.creme_core.bricks as core_bricks
    from creme.creme_core.models import BrickDetailviewLocation

    from .bricks import BeaverAgeBrick
    from .models import Beaver


    class Populator(BasePopulator):
        [...]

        # This method is defined in 'BasePopulator' & is called automatically
        # when you populate the data-base for the first time.
        def _populate_bricks_config(self):
            LEFT  = BrickDetailviewLocation.LEFT
            RIGHT = BrickDetailviewLocation.RIGHT
            create_bdl = BrickDetailviewLocation.objects.create_if_needed

            # This is the brick which displays the different fields of beavers
            BrickDetailviewLocation.objects.create_for_model_brick(order=5, zone=LEFT, model=Beaver)

            # These bricks from creme_core are generally present on all detailed view
            create_bdl(brick=core_bricks.CustomFieldsBrick, order=40,  zone=LEFT,  model=Beaver)
            create_bdl(brick=core_bricks.PropertiesBrick,   order=450, zone=LEFT,  model=Beaver)
            create_bdl(brick=core_bricks.RelationsBrick,    order=500, zone=LEFT,  model=Beaver)
            create_bdl(brick=core_bricks.HistoryBrick,      order=30,  zone=RIGHT, model=Beaver)

            # Here our new brick
            create_bdl(brick=BeaverAgeBrick, order=40, zone=RIGHT, model=Beaver)

            # Classically we add the bricks from the app "assistants" too (we check it is installed of course).
            # You can look in an existing Creme app how to do if you're interested...


Using buttons
~~~~~~~~~~~~~

Some buttons can be placed in detailed views, just below the title brick,
where is displayed the entity name. You can can generally choose if these
buttons are displayed or not, by configuration.

We will use this feature to create a ``Ticket`` (from the app *tickets*),
destined to veterinaries, which we can create when a beaver is sick.

We start with a creation view for ``Ticket``. As the button will be placed on
the detailed view of beavers, and when we will create a ticket from the page
of a sick beaver, this ticket references automatically the beaver, we pass
the ID of the beaver in the URL, in order the view can retrieve it.

In a new view file ``my_project/beavers/views/ticket.py``: ::

    from django.shortcuts import get_object_or_404
    from django.utils.translation import gettext as _

    from creme.tickets.views.ticket import TicketCreation

    from ..models import Beaver


    class VeterinaryTicketCreation(TicketCreation):
        def get_initial(self):
            initial = super().get_initial()
            initial['title'] = _('Need a veterinary')

            beaver = get_object_or_404(Beaver, id=self.kwargs['beaver_id'])
            self.request.user.has_perm_to_view_or_die(beaver)  # We use the beaver's name just after
            initial['description'] = _('{} is sick.').format(beaver)

            return initial


In ``beavers/urls.py``: ::

    [...]

    from .views import beaver, ticket  # <- UPDATE

    [...]

        re_path(
            r'^ticket/add/(?P<beaver_id>\d+)[/]?$',
            ticket.VeterinaryTicketCreation.as_view(),
            name='beavers__create_ticket',
        ),  # <- NEW

    [...]


Let's create the file ``beavers/buttons.py`` (this name is not mandatory, but
it's a convention): ::

    from django.utils.translation import gettext_lazy as _

    from creme.creme_core.gui.button_menu import Button

    from .constants import UUID_STATUS_SICK
    from .models import Beaver


    class CreateTicketButton(Button):
        id = Button.generate_id('beavers', 'create_ticket')
        verbose_name = _('Create a ticket for sick beaver')
        template_name = 'beavers/buttons/ticket.html'
        permissions = 'tickets.add_ticket'

        def get_ctypes(self):
            return (Beaver,)

        def is_displayed(self, *, entity, request):
            return (str(entity.status.uuid) == UUID_STATUS_SICK)

        # def get_context(self, *, entity, request):
        #     context = super().get_context(entity=entity, request=request)
        #     context['variable_name'] = 'VALUE'
        #     return context

Some explanations :

- The attribute ``permissions`` is a string or a list of strings using
  Django's conventions for permissions, with a shape : 'APP-ACTION' or
  ['APP-ACTION', …].
- The method ``get_ctypes()`` can precise, if it exists, the entity types which
  are compatible with the button : the button will only be proposed in the
  configuration for these types.
- The method ``ok_4_display()`` if it is overridden, like here, permit to
  display the button with some conditions (the button is display if the method
  returns ``True``). In our example we display the button only for beavers with
  status "Sick".
- The method ``get_context()`` allows you to customise the render, by adding data
  in the template context; an example of code has been kept in comments.

Now we write the related template,
``beavers/templates/beavers/buttons/ticket.html``: ::

    {% load i18n creme_widgets %}
    {% if button.permission_error %}
        <span class="menu_button menu-button-icon forbidden" title="{{button.permission_error}}">
            {% widget_icon name='ticket' size='instance-button' label=_('Linked ticket') %}
            {% translate 'Notify a veterinary' %}
        </span>
    {% else %}
        <a class="menu_button menu-button-icon" href="{% url 'beavers__create_ticket' object.id %}">
            {% widget_icon name='ticket' size='instance-button' label=_('Linked ticket') %}
            {% translate 'Notify a veterinary' %}
        </a>
    {% endif %}

The variable ``button.permission_error`` is filled thanks to the attribute ``permissions``
of our button ; we display an inactive button if the user is not allowed to use
the view. Notice that the tag ``<a>`` references a URL which is not associated
to a view (yet).

We have to register our button with other Creme buttons, in order to
*creme_config* could propose it. So we add in ``beavers/apps.py`` the method
``register_buttons()``: ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_buttons(self, button_registry):  # <- NEW
            from . import buttons

            button_registry.register(buttons.CreateTicketButton)


If we go to the configuration menu (the small gear), then 'Button menu',
and we edit the configuration of a type different of Beaver, our button
is not proposed (as we expected). On the other hand, it is proposed if we
create a configuration for the le type Beaver. Add the button on this new
configuration.

When we go to the page of a sick beaver (i.e. with the status "Sick"), the
button is appeared. If we click on it, we get a partially pre-filled form.


Using quick creation
~~~~~~~~~~~~~~~~~~~~

In the menu entry '+ Creation', their is the section 'Quick creation' which
gives the possibility to create some entities with a small popup (and not by
going to a new page with a big form).

The quick creation forms are generally, and for obvious reasons, simplified
versions of the entities forms. For example, the quick creation form for
Organisations has only 2 fields ("name" et "owner").

These forms are also used in some entity selection *widgets*, which allow to
create entities on-the-go.

In ``forms/beaver.py``, add a form class ; it must inherit the class
``CremeEntityQuickForm``: ::

    [...]

    from creme.creme_core.forms import (
        CremeEntityForm,
        CremeEntityQuickForm,  # <== NEW
    )

    [...]

    class BeaverQuickForm(CremeEntityQuickForm):  # <== NEW
        class Meta(CremeEntityQuickForm.Meta):
            model = Beaver
            fields = ('name', 'birthday')

Unlike the ``CremeEntityForm`` which by default creates fields for all the
attributes of the model, the ``CremeEntityQuickForm`` does not use any attribute,
so we must specify our fields explicitly when creating our form.

Then in our ``apps.py``, add the method ``register_quickforms()`` like
that: ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_quickforms(self, quickform_registry):  # <- NEW
            from .forms.beaver import BeaverQuickForm
            from .models import Beaver

            quickform_registry.register(Beaver, BeaverQuickForm)


**Beware** : register only models inheriting ``CremeEntity``. If you register
other types of classes, only super-users will see these entries (because the
credentials checking are avoided for them). It's an UI choice and an
implementation limitation ; it could change in the future.


CustomForms
~~~~~~~~~~~

As seen with the development of our first views with a form, Creme uses
generally for its own entity types some forms which users can configure
with a GUI : customisable forms (CustomForms).

Let's add a simple CustomForm to create our beavers. First, in the root of our
app (i.e. ``my_project/beavers/``), we create le file ``custom_forms.py``: ::

    from django.utils.translation import gettext_lazy as _

    from creme.creme_core.gui.custom_form import (
        CustomFormDefault,
        CustomFormDescriptor,
    )

    from .models import Beaver

    class BeaverFormDefault(CustomFormDefault):
        # NB: adapt depending on the fields of your model of course.
        # Notice that:
        #  - the field 'description' is not in the list; CustomFormDefault puts
        #    it in a separated group by default.
        #  - groups for properties and relationships are added by the default
        #    implementation.
        main_fields = [
            'user',
            'name',
            'birthday',
            'status',
        ]


    BEAVER_CREATION_CFORM = CustomFormDescriptor(
        id='beavers-beaver_creation',
        model=Beaver,
        verbose_name=_('Creation form for beaver'),
        default=BeaverFormDefault,
    )


Be careful and give it a unique identifier ; by prefixing it with the app name
we should be safe. In our file ``populate.py``, we indicate the fields used by
the default configuration of our CustomForm: ::

    [...]

    from . import custom_forms


    class Populator(BasePopulator):
        CUSTOM_FORMS = [custom_forms.BEAVER_CREATION_CFORM]

        [...]


Then, we declare our form descriptor ; in our file ``beavers/apps.py``, we add
a new method: ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_custom_forms(self, cform_registry):
            from . import custom_forms

            cform_registry.register(custom_forms.BEAVER_CREATION_CFORM)


If you run the command ``creme_populate``, you should get your form in the list
of configurable form (Menu > Configuration > Custom forms), related to your model.

The last thing is to modify our creation view, in order it uses our
CustomForm ; edit ``views/beaver.py``: ::

    [...]

    from .. import custom_forms

    class BeaverCreation(generic.EntityCreation):
        model = Beaver
        form_class = custom_forms.BEAVER_CREATION_CFORM  # <== NEW


Now our creation view should use the configuration you gave to the form.

**Going a bit further** : there are several ways to make more specific treatments
in a Customform, using some attributes of ``CustomFormDescriptor`` :

- you can exclude fields with the attribute ``excluded_fields``.
- you can specify the base class the generated form will use with the
  attribute ``base_form_class``. Beware the class you pass must inherit the
  classe ``creme_core.forms.base.CremeEntityForm``, and it should avoid to
  define any fields (the idea is to put code in the methods``clean()`` or
  ``save()``).
- it's possible to add special fields, which does not necessarily correspond to
  model fields, with the attribute ``extra_sub_cells``. For example, the app
  ``products`` uses it to generate a field which manages the
  categories/sub-categories.
- it's even possible to declarer whole special groups (which are not
  configurable, and will just be present or not, depending on the
  configuration) with the attribute ``extra_group_classes``. You should use
  this solution in last resort (use the previous solutions if you can). But if
  you really need to, you can look at the app ``persons`` which uses it for the
  block "Addresses".


Function fields
~~~~~~~~~~~~~~~

They are fields which does not exist in data base, and which can compute
results or perform queries in order to show useful information to users. They
are available in list-views and in custom bricks.

In our example, the function field display the age of a beaver. Add a file
``my_project/beavers/function_fields.py``: ::

    from datetime import date

    from django.utils.translation import gettext
    from django.utils.translation import gettext_lazy as _

    from creme.creme_core.core.function_field import FunctionField


    class BeaverAgeField(FunctionField):
        name = 'beavers-age'
        verbose_name = _('Age')

        def __call__(self, entity, user):
            birthday = entity.birthday

            return self.result_type(
                gettext('{} year(s)').format(date.today().year - birthday.year)
                if birthday else
                gettext('N/A')
            )


The attribute ``name`` is used as identifier. The attribute ``verbose_name``
is used for example in the list-view as column title (like the attribute
``verbose_name`` of the model fields for example).

**Note** : the result must have the type ``FunctionFieldResult`` (or one of its
child classes, like ``FunctionFieldDecimal`` or ``FunctionFieldResultsList``),
which is the default value of ``FunctionField.result_type`` ; this type will
allow to format correctly the value, because we could display HTML or export
CSV.

Then in your ``beavers/apps.py``, add the method ``register_function_fields()``
like this: ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_function_fields(self, function_field_registry):  # <- NEW
            from . import function_fields
            from .models import Beaver

            function_field_registry.register(Beaver, function_fields.BeaverAgeField)


**Notes** : as you give the model related to your function field, it's easy to
expand a model from another app. And as functions fields are inherited, if you
add one to ``CremeEntity``, it will be available for every entity type.

**Going a bit further** : it's possible to put a search field in the column of
list-views corresponding to your ``FunctionField``. Set the class attribute
``search_field_builder`` with a class inheriting
``creme.creme_core.forms.listview.ListViewSearchField``. It's mostly a form
field (with especially a related widget), but its method ``to_python()``
must return an instance of ``django.db.models.query_utils.Q``. You can find
some examples of use in the following files :

- ``creme/creme_core/function_fields.py`` : it searches in the entities having
  a CremeProperty among a list of available CremeProperty.
- ``creme/assistants/function_fields.py`` : it searches in the entities having
  an Alert, through its title.


Search in the list-view
~~~~~~~~~~~~~~~~~~~~~~~

In the previous paragraph, we explained how to code a list-view search related
to function field. Indeed it's possible to do the same thing with every column.
Some search fields are defined by default (see
``creme/creme_core/gui/listview/search.py``), but you can, for example :

- override the existing behaviours.
- define the behaviours for your own class of model fields.

You'll have to create a class inheriting
``creme.creme_core.forms.listview.ListViewSearchField`` (recall: it's a form
field which generate an instance of ``django.db.models.query_utils.Q``). This
class must be registered into Creme, with the method
``register_search_fields()`` in your ``apps.py``.

**Example** : in the app ``persons``, the behaviour of the search for
``ForeignKeys`` related to the model ``Address`` has been customised, in order
to search in the sub-fields of ``Address`` instances.

The search field is defined in ``creme/persons/forms/listview.py``: ::

    from django.db.models.query_utils import Q

    from creme.creme_core.forms import listview

    # We inherit the base class for search fields.
    class AddressFKField(listview.ListViewSearchField):

        # We want an simple text <input> as widget.
        widget = listview.TextLVSWidget

        def to_python(self, value):
            # We manage empty search case.
            if not value:
                return Q()

            [...]

            # Notice the attribute "cell" with type 'creme_core.core.entity_cell.EntityCell' ;
            # it's used here to get the name of the 'ForeignKey'.
            fk_name = self.cell.value

            # We build our instance of Q(), and return it
            q = Q()
            for fname in address_field_names:
                q |= Q(**{f'{fk_name}__{fname}__icontains': value})

            return q


In ``creme/persons/apps.py``, we register the search field: ::

    class PersonsConfig(CremeAppConfig):
        [...]

        def register_search_fields(self, search_field_registry):
            from django.db.models import ForeignKey

            from creme.creme_core.core.entity_cell import EntityCellRegularField

            from .forms.listview import AddressFKField

            # 'search_field_registry' is a tree registry ; we retrieve in the following order:
            #  - the sub-registry for regular fields.
            #  - the sub-registry for 'ForeignKeys'.
            # Then we declare our search field is related to the model 'Address'.
            search_field_registry[
                EntityCellRegularField.type_id
            ].builder_4_model_field_type(ForeignKey).register_related_model(
                model=self.Address, sfield_builder=AddressFKField,
            )


Actions in the list-view
~~~~~~~~~~~~~~~~~~~~~~~~

In list-views, there is a column to trigger some actions (e.g. clone an entity).
On each line, we find a menu to make actions related to the entity
corresponding to this line ; and in the list header there is a menu with
actions that use several entities in the same time.

You can code your own actions ; they can be available for all entities (by
associating them to the model ``CremeEntity``) or for a specific type like
beavers.

In this example, imagine we already have a view which generates barcode (as an
downloaded image) corresponding to a beaver ; then we create an action to
download the barcode from the actions menu of a beaver in the list-view.

Add a file ``beavers/actions.py`` like: ::

    from django.urls.base import reverse
    from django.utils.translation import gettext_lazy as _

    from creme.creme_core.gui.actions import UIAction

    from .models import Beaver


    class GenerateBarCodeAction(UIAction):
        id = UIAction.generate_id('beavers', 'barcode')
        model = Beaver

        type = 'redirect'
        url_name = 'beavers__barcode'

        label = _('Generate a bar code')
        icon = 'download'

        @property
        def url(self):
            return reverse(self.url_name, args=(self.instance.id,))

        @property
        def is_enabled(self):
            return self.user.has_perm_to_view(self.instance)


Some explanations :

- ``id`` : must be unique (among the actions), and as usual it's used during
  registration of the action to retrieve it later.
- ``model`` : model for which the action is available. Here we set our specific
  model, because our action does not mean anything for other types of entity.
- ``type`` : it determines the behaviour of the action in the UI. To create a
  new type you need to write some JavaScript (we'll avoid that to keep this
  example simple). Here, the type "download" is a base type which redirect
  to a URL (so it's often used).
- ``icon`` :  name of the icon to use with ``label`` in the GUI ;
  beware the final file name is generated by Creme, like "download_22.png".
- ``is_enabled()`` : if ``False`` is returned, the entry is disabled.

**Notes** : the view named "beavers__barcode" remains to be coded of course,
but its not the objective of this example.

The last thing is to declare our action in our ``apps.py``: ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_actions(self, action_registry):  # <- NEW
            from . import actions

            action_registry.register_instance_actions(
                actions.GenerateBarCodeAction,
            )


**Going a bit further** : to code an action managing several entities at once,
an action class must inherit ``creme.creme_core.gui.actions.UIAction``
and must be registered with ``action_registry.register_bulk_actions``.


Sending notifications
~~~~~~~~~~~~~~~~~~~~~

Sometimes you want to inform some users about a thing. It can be an event which
will happen (e.g. Creme averts you that one of your Alerts is about to expire)
or an action which has been performed by another user (e.g. Creme averts you
that an administrator has changed your password).

Even if you can use an existing channel, we will here create a channel specific
to your app. First we add an UUID which we'll use to retrieve our channel; in
``beavers/constants.py`` write this: ::

    [...]

    # Generate a value in your Python shell with uuid.uuid4
    UUID_CHANNEL_BEAVERS = 'dccfcde6-e9c1-4d5e-aa31-1f42dc8d94fb'


We have to create the channel's type too; add a new file
``beavers/notification.py`` like: ::

    from django.utils.translation import gettext_lazy as _

    from creme.creme_core.core.notification import NotificationChannelType


    class BeaversChannelType(NotificationChannelType):
        id = NotificationChannelType.generate_id('beavers', 'main')
        verbose_name = _('Beavers')
        description = _('Important information about beavers')


Then we must declare our type in ``beavers/apps.py``: ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_notification(self, notification_registry):
            from .notification import BeaversChannelType

            notification_registry.register_channel_types( BeaversChannelType)


Now we create the channel in ``beavers/populate.py``: ::

    [...]
    from creme.creme_core.core.notification import OUTPUT_WEB
    from creme.creme_core.models import NotificationChannel

    from .notification import BeaversChannelType

    [...]

    class Populator(BasePopulator):
        NOTIFICATION_CHANNELS = [
            NotificationChannel(
                uuid=constants.UUID_CHANNEL_BEAVERS,
                type=BeaversChannelType,
                default_outputs=[OUTPUT_WEB],
            ),
        ]

        [...]


We can now send notifications in our code like this: ::

        from creme.creme_core.models import Notification

        from my_project.beavers.constants import UUID_CHANNEL_BEAVERS

        [...]
        Notification.objects.send(
            channel=UUID_CHANNEL_BEAVERS,
            users=[user1, user2],
            content=SimpleNotifContent(
                subject='A beaver is sick',
                body='Call a vet please',
                # NB: there is a parameter "html_body" too.
            ),
        )


**Going further** : we've used the content class ``SimpleNotifContent`` which is
provided by default for the most simple cases. You can write your own content
classes for the more complex cases, for example:

 - to have dynamically translated messages using the target user's language.
 - to display links to entities, with care of credentials and deleted entities.

You can look at ``creme.assistants.notification.AlertReminderContent`` to see
what is possible.


Modifying the base template
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The variable ``settings.BASE_HTML`` allows to customise the template used as
base by all pages, to modify the <head> part for example.

If it's possible, your own base template should inherit the default base template,
in order to minimise the copy-pasted parts and facilitate the upgrades of Creme.
For example, create the file ``my_project/beavers/templates/beavers/my-base.html`` : ::

    {% extends 'creme_core/base.html' %}

    {% block %}
        {{block.super}}
        <meta name="publisher" content="Beaver corp.">
    {% endblock %}


and set in ``my_project/settings.py`` : ::

    BASE_HTML = 'beavers/my-base.html'


**See also** : there is a variable ``settings.BASE_HTML_EXTRA_INCLUDED``
which allows to include directly some templates in the base template, at the end
of "<body>". It's useful to add a tag "<script>" everywhere without having to
define ``settings.BASE_HTML`` for example.


Modifying existing apps
~~~~~~~~~~~~~~~~~~~~~~~

It's a common need to modify the behaviour of existing apps. Many companies
code their own CRM because it's hard for this kind of software to manage all
specific use cases.

The fact than you can directly modify the code of Creme is of course a good
thing ; whichever the modification you want, it will be possible with this way
(while mechanisms presented below will always have limits).

Moreover, if it's possible, you should use the tools proposed by
Creme/Django/Python (in this order of priority) to modify the code of existing
apps from your own code. So the design will remain modular and upgrade of Creme
will be easier.

By the way, it's a really good idea to write unit tests
(`Unit tests and tests driven development`_) to check your new behaviours
(particularly when you upgrade the version of Creme) ; in practice you can copy
the existing unit tests for modified code in your own tests files, and just
modify the copies as you wish (instead of coding them from scratch).


General approaches
******************

**Monkey patching** : this way is quite brutal and should be used carefully,
and avoided whenever it's possible.
Thanks to Python's dynamism, it's possible to override some elements of another
module.
For example, in ``creme/creme_core/apps.py``, we find this code which modifies
the method ``ForeignKey.formfield()`` (defined in Django): ::

    [...]

    class CremeCoreConfig(CremeAppConfig):
        [...]

        @staticmethod
        def hook_fk_formfield():
            from django.db.models import ForeignKey

            from .models import CremeEntity

            from creme.creme_config.forms.fields import CreatorModelChoiceField

            # Here we store the original method...
            original_fk_formfield = ForeignKey.formfield

            def new_fk_formfield(self, **kwargs):
                [...]

                defaults = {'form_class': CreatorModelChoiceField}
                defaults.update(kwargs)

                # ... that we call here.
                return original_fk_formfield(self, **defaults)

            ForeignKey.formfield = new_fk_formfield  # We override with our own method.


**Global variables & class attributes** : the code of Creme/Django is often
designed to be easily modified from outside, without needing a complex API. You
just have to look the source code and understand it.
For example, in the form fields classes, the related widget is build by using
the class given in the well-named attribute ``widget``.
So it's easy to modify it ; here some code found in ``creme/creme_core/apps.py``: ::

    [...]

    class CremeCoreConfig(CremeAppConfig):
        [...]

        @staticmethod
        def hook_datetime_widgets():
            from django import forms

            from creme.creme_core.forms import widgets

            # We set the Creme widgets as default widgets. So, when a form is
            # generated from a model, the widgets are automatically the "right" ones.
            forms.DateField.widget     = widgets.CalendarWidget
            forms.DateTimeField.widget = widgets.DateTimeWidget
            forms.TimeField.widget     = widgets.TimeWidget

We could do the same thing with the class attributes of views (we are only
talking about class-based views, not functions ones of course).

In a global manner, behaviours in Creme are often stored in global
dictionaries, instead of ``if … elif … elif …`` blocks. so it's easy to
add, remove or modify these behaviours.

**AppConfig** : Django allows, in the variable ``settings.INSTALLED_APPS``,
to specify the class of AppConfig used by an app.
Imagine you want to remove all the activities' statistics from the statistics
brick (see `Statistics brick`_).
Dans ``my_project/settings.py``, add the following lines: ::

    INSTALLED_CREME_APPS.remove('creme.activities')
    INSTALLED_CREME_APPS.add('my_project.beavers.apps.BeaversActivitiesConfig')

Then in ``my_project/beavers/apps.py``, we create effectively this configuration
class: ::

    [...]

    from creme.activities.apps import ActivitiesConfig

    # We inherit the original class, to keep all the other methods identical.
    class BeaversActivitiesConfig(ActivitiesConfig):
        def register_statistics(self, statistic_registry):
            pass  # the method does nothing now


Hooking forms
*************

In Creme, form classes have 3 methods which allow to change their behaviour
without modifying their code directly :

 - ``add_post_init_callback()``
 - ``add_post_clean_callback()``
 - ``add_post_save_callback()``

They take a function as only parameter ; as their names suggest, these
functions are callbacks, called respectively after the calls to ``__init__()``,
``clean()`` and ``save()``. These callbacks must have only one parameter, the
form instance.

**Notes** : with CustomForms and form classes declared as class attribute of
view classes, hooking regular form classes became quite less useful.

The simplest way to hook the wanted forms is from the file ``apps.py``
of one of your own apps (like *beavers*), in the method ``all_apps_ready()``.
Here an example which adds a field in the creation form for users (notice you
should hook the method ``save()`` too, in order to use this new field ; this
task is left as exercise...): ::

    [...]

    class BeaversConfig(CremeAppConfig):
        name = 'my_project.beavers'
        verbose_name = _('Beavers management')
        dependencies = ['creme.creme_core']

        def all_apps_ready(self):
            super(BeaversConfig, self).all_apps_ready()

            from django.forms.fields import BooleanField

            # NB: we perform imports of other apps here to avoid error of loading order
            from creme.creme_config.forms.user import UserAddForm

            def add_my_field(form):
                form.fields['loves_beavers'] = BooleanField(required=False, label=_('Loves beavers?'))

            UserAddForm.add_post_init_callback(add_my_field)

        [...]


**Technical note** : ``all_apps_ready()`` is an improvement from Creme to
Django, which only defines the method ``ready()``. If you need to import
directly or indirectly code from other apps, use ``all_apps_ready()`` rather
than ``ready()`` ; in other cases use ``ready()`` because it's more classical.

**Technical note** : in reason of the moment when *callbacks* are called, it's
possible, depending on the form you are caring about, that you cannot do what
you want (for example get a field created after the call to the callbacks).


Overriding the templates
************************

As seen before, it's possible, to modify from your app the attribute
``template_name`` of class-based views, in order to force a view in another app
to use a template of your app. The advantage is your template could extend the
replaced template ; it's useful when the new template si nearly equal to the
replaced one (it has to use smartly tags ``{% block %}`` of course).

But if if not possible (or wanted), there is another way to make another app
use your own templates : template overriding. You just have to use the Django's
templates loading system.

In the file ``creme/settings.py``, you can find the following variable: ::

    TEMPLATES = [
        {
            ...

            'OPTIONS': {

                ...

                'loaders': [
                    # Don't use cached loader when developing (in your local_settings.py)
                    ('django.template.loaders.cached.Loader',
                        'django.template.loaders.filesystem.Loader',
                        'django.template.loaders.app_directories.Loader',
                    )),
                ],

                ...
            },
        },
    ]


The order of loaders is important ; this order makes the templates present in
the directory ``creme/templates/`` used instead of templates in directories
``templates/`` found in the apps directories.

Example : instead of modifying directly the template
``creme/persons/templates/persons/view_contact.html``, you can put your
modified version in the file ``creme/templates/persons/view_contact.html``.


Overriding labels
*****************

It's a current need to customise some labels ; for example, replace les
occurrences of 'Organisation' by 'Association'.

Run the following command: ::

    > creme i18n_overload --settings=my_project.settings -l fr organisation Organisation


Then you have to edit the new translation file created in ``my_project/locale_overload/``
(it's indicated by the command). In our example, we replace 'Organisation' by
'Association'. Do not forget to remove the lines "#, fuzzy".
Finally, compile these new translations as seen before: ::

    > creme compilemessages --settings=my_project.settings


Storing additional data in an existing model
********************************************

The model ``CremeEntity`` most of the small models (sector, status…)
get a JSON field ``extra_data``. It allows to store data at instance level without
having to modify the models or to create a model dedicated to these data.

This field is not visible by users, and you can even use it to filter instances: ::

    # In your file 'beavers.constants.py' --------------------------------------
    TAG_COMPANY = 1
    TAG_COMMUNITY = 2

    # In your code for views, forms, bricks... ---------------------------------
    from creme.persons import get_organisation_model
    from my_project.beavers.constants import TAG_COMPANY
    [...]

    orga = get_organisation_model().objects.get(name='Acme').first()
    [...]

    # Assign a value
    orga.extra_data['tag'] = TAG_COMPANY
    orga.save()
    [...]

    # Test a value
    if orga.extra_data.get('tag') == TAG_COMPANY:
        [...]

    # Filter instances with a value
    for orga in get_organisation_model().objects.filter(extra_data__tag=TAG_COMPANY):
        [...]

**Going further** : you can also set several tags on the same entity, with a
list instead of a simple integer. Beware, some filter operations could not work
depending on your database engine  : ::

    [...]
    orga.extra_data['tags'] = [TAG_FOO, TAG_BAR]
    orga.save()

    # Works with PostgreSQL & MySQL, but not SQlite
    for orga in get_organisation_model().objects.filter(extra_data__tags__contains=TAG_FOO),


Modifying an existing model
***************************

Another current need is to modify an existing model, provided by Creme, for
example adding some fields to Contact, or remove ones.

In you want to **add some fields**, the simplest way is to use some CustomFields, which
you add from the configuration GUI. But it's not possible (yet) to add business
logic to these fields, like computing automatically their value for example.

Another way is to create a model in your app, which references the existing
model (``ForeignKey``, ``ManyToManyField``, ``OneToOneField``). This is the
method used by the app ``geolocation`` to extend the addresses from the app
``persons`` with information of geographical localisation. You may have to use
additionally other techniques to get the expected result :

 - Use of Django's signals (``pre_save``, ``post_save`` …).
 - `Hooking forms`_ (vu précédemment)


if you want to **hide some fields**, remind you that lots of fields are
marked as optional, and so they can be hidden thanks to the configuration UI.

**In last resort**, if you really want to modify an existing model, there is the
possibility to swap it. Nonetheless, the model must be swappable ; this is the
case of all classes inheriting ``CremeEntity`` ( ``Contact``, ``Organisation``,
``Activity`` …), and ``Address`` too.

In a first time, we considerate that you want to perform this swapping at the
project beginning ; it means that you don't have a production DB using the model
you want to modify. So, you start the development and you already know that you
want modify this model.

In our example we swap ``tickets.Ticket``.

First, we create an app destined to extend ``tickets`` ; we name it
``my_tickets``. So, we have to do the same things than for theapp ``Beavers`` :
create a directory ``my_project/my_tickets/``, containing the usual files
``__init__.py``, ``apps.py``, ``models.py``, ``urls.py`` …
This app must be added in INSTALLED_APPS ; beware it must be before ``tickets``
(with ``INSTALLED_APPS.insert()``).

Our ``AppConfig`` must declare that it extends ``tickets``: ::

    from django.utils.translation import gettext_lazy as _

    from creme.creme_core.apps import CremeAppConfig


    class MyTicketsConfig(CremeAppConfig):
        name = 'my_project.my_tickets'
        verbose_name = _('Tickets')
        dependencies = ['creme.tickets']
        extended_app = 'creme.tickets'  # <= HERE !!
        credentials  = CremeAppConfig.CRED_NONE  # <= and HERE !!


In ``my_project/models.py``, we must define a model which will replace
``tickets.models.Ticket``. The easier way is to inherit
``tickets.models.AbstractTicket`` (notice that all entity type use a similar
scheme). It's important to keep ``Ticket`` as model name, in order to avoid
lots of annoying behaviours or bugs: ::

    from django.db.models import DecimalField
    from django.utils.translation import gettext_lazy as _

    from creme.creme_core.models import CremeModel

    from creme.tickets.models import AbstractTicket


    class Ticket(AbstractTicket):
        estimated_cost = DecimalField(
            _('Estimated cost (€)'),
             blank=True, null=True, max_digits=10, decimal_places=2,
        )  # <= ADDITIONAL FIELD

        class Meta(AbstractTicket.Meta):
            app_label = 'my_tickets'


In ``creme/settings.py``, found a variable with shape ``<APP>_<MODEL>_MODEL`` ; in
our case this is: ::

    TICKETS_TICKET_MODEL = 'tickets.Ticket'

We override this variable in our file ``my_project/settings.py``: ::

    TICKETS_TICKET_MODEL = 'my_tickets.Ticket'

It indicates the concrete class to use instead of ``tickets.Ticket``.

We can now generate the migrations as seen before.

If you look at ``creme/tickets/urls.py``, you can see the way URLs are defined is
sometimes a bit different from the usual way.
For example: ::

    [...]

    urlpatterns += swap_manager.add_group(
        tickets.ticket_model_is_custom,
        Swappable(re_path(r'^tickets[/]?$',                        ticket.TicketsList.as_view(),    name='tickets__list_tickets')),
        Swappable(re_path(r'^ticket/add[/]?$',                     ticket.TicketCreation.as_view(), name='tickets__create_ticket')),
        Swappable(re_path(r'^ticket/edit/(?P<ticket_id>\d+)[/]?$', ticket.TicketEdition.as_view(),  name='tickets__edit_ticket'), check_args=Swappable.INT_ID),
        Swappable(re_path(r'^ticket/(?P<ticket_id>\d+)[/]?$',      ticket.TicketDetail.as_view(),   name='tickets__view_ticket'), check_args=Swappable.INT_ID),
        app_name='tickets',
    ).kept_patterns()

    [...]

These URLs (we can see that ``re_path()`` is called, the code is wrapped in
other calls) are only defined when the model ``Ticket`` is not swapped.

These views cannot respect your business logic ; for example the creation view
can crash if you added in ``my_tickets.models.Ticket`` a model field which is
mandatory and not editable at the same time. Since we chose to define our own
customised model, we must provide our own URLs which are sure to work.

In our case, the base views should be enough (forms are smart enough to use the
new editable fields), and so you can define ``my_project/my_tickets/urls.py`` like: ::

    from django.urls import re_path

    from creme.tickets.views import ticket

    urlpatterns = [
        re_path(r'^my_tickets[/]?$',                        ticket.TicketsList.as_view(),    name='tickets__list_tickets'),
        re_path(r'^my_ticket/add[/]?$',                     ticket.TicketCreation.as_view(), name='tickets__create_ticket'),
        re_path(r'^my_ticket/edit/(?P<ticket_id>\d+)[/]?$', ticket.TicketEdition.as_view(),  name='tickets__edit_ticket'),
        re_path(r'^my_ticket/(?P<ticket_id>\d+)[/]?$',      ticket.TicketDetail.as_view(),   name='tickets__view_ticket'),
    ]

**Note** : the most important is to define URLs with the same name (used by
``reverse()``), and the same arguments ("ticket_id" here). To avoid errors,
Creme checks at starting that all swapped URLs have been defined elsewhere.

In the most complex cases, you'll probably want to use your own forms or
templates. You may have to define your own views. Try to avoid "copy/paste"
each time it's possible ; the base apps provide class-based views which can
easily be extended. For example, if you want to define the creation view
``my_tickets.models.Ticket`` with your own form (writing it won't be treated,
you already know how to do), you could write something like that: ::

    from creme.tickets.views.ticket import TicketCreation

    from my_project..my_tickets.forms import MyTicketForm  # <= to be writen !


    class TicketCreation(TicketCreation):
        form_class = MyTicketForm


**Going a bit further** : you've maybe noticed that in ``creme/settings.py``
there are variable looking like forme ``<APP>_<MODEL>_FORCE_NOT_CUSTOM``
(for example ``TICKETS_TICKET_FORCE_NOT_CUSTOM``). As seen before, it's better
to swap before the creation of the data base. But you could think that a model
will be swapped in the future, without being sure about that. And even by swapping
it immediately, you could have not enough time to code its views. The variables
``*_FORCE_NOT_CUSTOM`` are useful in this case. You can swap some model as a
precaution, but force Creme to considerate these models as not customised ;
so 'normal' views (and unit tests too) will be used anyway. Nevertheless, you
must be careful and use only models which are identical to the base model
(e.g. just inherit from abstract models). Otherwise, the base views may work
not correctly. So use these variables carefully.

**How-to swap a model in a second time?** imagine you have a production
instance of Creme, and then you realise that to do want you want you have to
swap a model (i.e. it's the not swapped version of this model which is currently
used in your code/DB).

Beware! You should test the following step on a copy of your production DB, and
always have a backup before applying modifications (it's a general advice, but
it's particularly true with the tricky following manipulations).


#. Write a swapping model (in your own app of course), which must be
   **exactly identical** to the model used in DB. Indeed, you just have to
   inherit the corresponding abstract model (e.g. ``AbstractTicket``)
   **with no new field** (yet).

#. Edit the setting ``<APP>_<MODEL>_MODEL`` to reference your model.

#. Beware, it's the trickiest step: rename the table corresponding to the base
   model (with PHPMyAdmin or pgAdmin for example), by giving it the name Django
   Django would give to the table of your model. The important thing is to
   follow the Django's convention. In the tickets' example we've seen before, it
   means rename the table "tickets_ticket" into "my_tickets_ticket". Normally,
   the modern RDBMS do a nice job, and the related constraints (like the
   ForeignKeys to this table) are correctly modified. But some old versions of
   MySQL seem to keep broken constraints, so it's important to test with an
   environment identical to your production environment.

#. Modify, in the table "django_content_type" the line corresponding to the
   model. E.g. the line app_label="tickets"/model="ticket" should now contain
   app_label="my_tickets" (model="ticket" does not change if you kept
   ``Ticket`` like recommended).

#. Generate the migration for your new model. nonetheless, like the table
   already exist in the base, we have to 'fake' this migration: ::

        > creme migrate --settings=my_project.settings my_tickets --fake-initial

#. As seen before, you have to manage the views of your new model.


Overriding existing URLs
************************

Imagine you want to make an existing URL to correspond to one of your view.
As seen before, when you swap a model, you have to re-define some of its
related views (creation, list-view, etc…) ; you could be in a different use
case :

- you did not swap the concerned model, and don't want to just to modify a view.
- the concerned view is not one of the views which have to be re-defined when
  swapping a model.

**Remark**: with class-based views, there are (as seen before), many ways to
modify an existing view from your app, without needing to re-write it totally.

In this example, we modify the creation view for memo. In
``creme/assistants/urls.py``, we find this code: ::

    [...]

    urlpatterns = [
        re_path(
            r'^memo/',
            include([
                re_path(
                    r'^add/(?P<entity_id>\d+)[/]?$',
                    memo.MemoCreation.as_view(),
                    name='assistants__create_memo',
                ),
                [...]
            ])),

        [...]
    ]

By default, the URLs of an app are prefixed by the name of the app itself,
so "assistants/" in our example. We have to :

- use an identical prefix.
- use an identical pattern.

When the URL list is created (see ``creme/urls.py``), apps are added in the order
of their declaration in ``settings.INSTALLED_APPS``. And the URL resolver will
stop on the first pattern which matches the searched URL. Conclusion, our app
must be **before** (in ``settings.INSTALLED_APPS``) the app containing the URL
we want to mask.

We can set explicitly the URL prefix of an app, to use the same as the app
``assistants``. It will impact all the URLs in our app, so it's cleaner to build
a minimal ap which only do this. And a different app has to be created for each
base app your want to URL-mask. Create an app ``my_assistants``; in the file
``my_project/my_assistants/apps.py``, write : ::

    [...]

    class MyAssistantsConfig(CremeAppConfig):
        name = 'my_project.my_assistants'

        url_root = 'assistants/'

        [...]

Then, in ``my_project/my_assistants/urls.py`` : ::

    from django.urls import re_path

    from . import views

    urlpatterns = [
        # Notice the URL must be the same than the original one.
        re_path(
            r'^memo/add/(?P<entity_id>\d+)[/]?$',
            views.MyMemoCreation.as_view(),
        ),
    ]

**Note** we did not give a name to our URL. We could name it with the same name
as the masked URL (so``name='assistants__create_memo'``), but it would be useless.

This method remains fragile, because if the masked URL changes in a future
(major) version of Creme, your view does not mask it anymore without
triggering error (the 2 URLs just cohabit). So you must use this method
carefully, and be careful when you upgrade Creme. Writing some unit tests which
check that ``reverse('assistants__create_memo')`` leads to our own view would
be a good idea.

**Specific case: removing a feature**: in some case you may want to disable an
existing base view. For example, you want Memos to be only created by a Job
which import then from an ERP system. To make this task correctly the creation
views for Memos cannot be reached.

So you should too remove menu entries and buttons which redirect to these
creation views, in order to get a clean UI without useless element ; these
things are treated in other parts of this document.

Creme provides a generic view which returns an error page to the user: ::

    from django.urls import re_path

    from creme.creme_core.views.generic.placeholder import ErrorView

    urlpatterns = [
        re_path(
            r'^memo/add/(?P<entity_id>\d+)[/]?$',
            ErrorView.as_view(message='Memo are only created by ERP.'),
            name='assistants__create_memo',
        ),
    ]


Modification of "populate" script
*********************************

The "populate" scripts are, as you may know, used by the command
"creme_populate" to fill the data base. If you want to modify this script for
an existing app, in order to a get a fresh installation more adapted to your use
(mainly if you want to deploy several instances).

Imagine you want to customise the app "persons" to have only in the blocks'
configuration for Contacts and Organisation the block which displays Alerts
(so no ToDo, Memo etc…).

In our file ``my_project/beavers/populate.py`` we add this code: ::

    [...]

    from creme.persons import populate as persons_populate

    class PersonsPopulator(persons_populate.Populator):
        # We retrieved the code of the base method, & we modify it as we want.
        def _populate_bricks_config_for_assistants(self):
            from creme.assistants.bricks import AlertsBrick

            for model in (self.Contact, self.Organisation):
                BrickDetailviewLocation.objects.create_if_needed(
                    model=model, brick=AlertsBrick,
                    order=100, zone=BrickDetailviewLocation.RIGHT,
                )


Now we just have to indicate to Creme to use this class instead of the default
one. In ``my_project/settings.py``, we add this variable: ::

    [...]

    POPULATORS = {
        'persons': 'my_project.beavers.populate.PersonsPopulator',
    }


Further with models: Tags
~~~~~~~~~~~~~~~~~~~~~~~~~

Creme provides a tag system for model fields in order ta add them semantic, and
have a more precise behaviour for some services. Currently, it's not possible
to create its own tags.

Example of use (with 2 tags configured at once): ::

    [...]

    class Beaver(CremeEntity):
        [...]
        internal_data = models.CharField(
            'Data', max_length=100,
        ).set_tags(viewable=False, clonable=False)


List of tags and their related features:

 - ``viewable``: classical fields (``IntegerField``, ``TextField``, …) are
   visible to the users. Sometimes, we want to store internal information that
   users should not see. Set this tag to ``False``, and it will be hidden
   everywhere.
 - ``clonable``: by setting this tag to ``False``, the field's value is not
   copied when the entity is cloned (more details in the section on
   entity cloning).
 - ``optional``: by setting this tag to ``True``, the field can be hidden by
   users in the fields' configuration UI ; the field is then removed from
   forms. It's obvious that this field does not need to be fille by form
   without causing an error ; for example it could be ``nullable`` or having a
   value for ``default``.
 - ``enumerable``: when a ``ForeignKey`` gets thsi tag with a ``False`` value,
   (default value is ``True``), Creme knows this FK could take an infinity of
   values, and so these values should never be proposed as choices, in filters
   for example.


Edition of a single field
~~~~~~~~~~~~~~~~~~~~~~~~~

All fields declared as ``editable=True`` in your entity models (it's the
default value) can be edited in the related detailed views, from the
information bricks (and in list-views too).
You just have to declarer your entity class as compatible, like this: ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_bulk_update(self, bulk_update_registry):
            bulk_update_registry.register(Beaver)

Notice that the fields declared as ``editable=True`` cannot be edited this way.

Sometimes, you want some fields are present in the creation form of your
entity, but you exclude then from the edition form (attribute ``exclude`` of
the class ``Meta`` in the form). In the same manner, you could want to avoid
the edition of some fields in the detailed view. So you have to use the method
``exclude()`` of the object returned by ``register()``: ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_bulk_update(self, bulk_update_registry):
            bulk_update_registry.register(Beaver).exclude('my_field1', 'my_field2')


If you want to customise th edition form for a particular field, because it has
some business logic for example: ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_bulk_update(self, bulk_update_registry):
            from .forms.my_field import MyOverrider

            bulk_update_registry.register(Beaver).add_overriders(MyOverrider)


The file ``my_project/beavers/forms/my_field.py`` looks like: ::

    from django.forms import ValidationError

    from creme.creme_core.gui.bulk_update import FieldOverrider

    class MyOverrider(FieldOverrider):
        # We'll build a complex form field which returns some consistent values
        # for 2 fields of our model
        field_names = ['my_field3','my_field4']

        def formfield(self, instances, user, **kwargs):
            return MyComplexFormField(label='Field3 & field4')

        def post_clean_instance(self, *, instance, value, form):
            # We extract 'value3' & 'value4' from "value", returned by our field
            [...]

            if really_important_check(value3):
                raise ValidationError('Blablabla')

            instance.my_field3 = value3
            instance.my_field4 = value4


Entity cloning
~~~~~~~~~~~~~~

If you want a model allows cloning (from the detailed view or the list view),
edit your ``apps.py`` : ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_cloners(self, entity_cloner_registry):
            entity_cloner_registry.register(model=Beaver)


The default behaviour copies :

 - the fields of your model with the *tag* ``clonable=True``. It's the default
   value, so if you want to exclude a field from the copy, set this *tag*
   to ``clonable=False``.
 - the custom fields.
 - the properties (``CremeProperty``) with a type which is marked as
   ``is_copiable=True``.
 - the relationships with a type which is marked as ``is_copiable=True`` and
   ``is_internal=False``.

**A bit further** : you can manage the cloning with a better granularity by
passing to the method ``register()`` an argument ``cloner_class``. In the file
``my_project/beavers/cloners.py``: ::

    from django.utils.translation import gettext_lazy as _

    from creme.creme_core.core.cloning import EntityCloner
    from creme.creme_core.core.copying import PreSaveCopier
    from creme.creme_core.core.exceptions import ConflictError

    from .constants import STATUS_SICK


    class DescriptionCopier(PreSaveCopier):
        def copy_to(self, target):
            target.description = f'{self._source.description} (cloned)'


    class BeaverCloner(EntityCloner):
        pre_save_copiers = [
            *EntityCloner.pre_save_copiers,
            DescriptionCopier,
        ]

        def check_permissions(self, *, user, entity):
            super().check_permissions(user=user, entity=entity)

            if str(entity.status.uuid) == UUID_STATUS_SICK:
                raise ConflictError(_('a sick beaver cannot be cloned'))


In this example :

 - we forbid cloning in some cases.
 - we customise the copy of data during cloning.

We have now to tell Creme it has to use our class: ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_cloners(self, entity_cloner_registry):
            from . import cloners

            entity_cloner_registry.register(
                model=Beaver, cloner_class=cloners.BeaverCloner,
            )


Import of CSV files
~~~~~~~~~~~~~~~~~~~

If you want to enable CSV/XLS import for your entity model, you have to add
this in your ``apps.py``: ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_mass_import(self, import_form_registry):
            import_form_registry.register(Beaver)


So the import form will be automatically generated. If you want to customise
this form, look at the code of apps ``persons``, ``activities`` or
``opportunities`` (it's out of the scope of this tutorial).


Merging 2 entities
~~~~~~~~~~~~~~~~~~

To enable the merging of your entity type, look how the apps ``persons`` or
``document`` do, in the method ``register_merge_forms()`` of ``apps.py`` (it's
out of the scope of this tutorial).

**Notes** : if you created a model related to an entity type which can be
merged, you can control more precisely what happens during the merge thanks to
the signals ``creme.creme_core.signals.pre_merge_related`` and
``creme.creme_core.signals.pre_replace_related``. and if your model is linked
through a ``OneToOneField``, you **must** manage the merge, because Creme cannot
manage automatically the case where the 2 merged entities are linked (one of
the 2 linked instances has to be removed, and some of the information may be
stored in the other one etc…).


SettingValues
~~~~~~~~~~~~~

This feature allow users to fill some typed values through a configuration UI
(contrarily to values in ``settings.py`` which can only be changed by the
administrator), in order to the code behave specifically depending on the
values.


Global settings
***************

The model ``SettingValue`` allow to retrieve some global values, ie their are
used for all the users.

In a new file ``my_project/beavers/setting_keys.py`` at your app's root: ::

    from django.utils.translation import gettext_lazy as _

    from creme.creme_core.core.setting_key import SettingKey

    beaver_key = SettingKey(
        id='beavers-my_key',
        description=_('*Set a description here*'),
        app_label='beavers',
        type=SettingKey.BOOL,
    )

We've just created a boolean value. Other available types are :

 - STRING
 - INT
 - BOOL
 - HOUR
 - EMAIL

**Note** : you should prefix the identifier of the setting key (the attribute
"id") with the app's name, in order to avoid collisions with keys in others
apps ; so to guaranty uniqueness. If the key is not unique an exception is
raised at start.

In ``my_project/beavers/populate.py``, we now create the related instance of
``SettingValue``, and we set its default value: ::

    [...]

    from creme.creme_core.models import SettingValue

    from .setting_keys import beaver_key


    class Populator(BasePopulator):
        SETTING_VALUES = [
            SettingValue(key=setting_keys.beaver_key, value=True),
        ]

        [...]


Now we register the key in Creme. In ``my_project/beavers/apps.py``: ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_setting_key(self, setting_key_registry):
            from .setting_keys import beaver_key

            setting_key_registry.register(beaver_key)


The value can now be set by users in the configuration portal of the app.

And to use the value in your code: ::

    from creme.creme_core.models import SettingValue

    from my_project.beavers.setting_keys import beaver_key


    if SettingValue.objects.get_4_key(beaver_key).value:
        [...]

**A bit further** : you can pass to your ``SettingKey`` the form-field to be
used when setting the related ``SettingValue``. Here an example where our value
will be an integer among some restricted choices, and the user choses among
some labels: ::

    from functools import partial

    from django import forms
    from django.utils.translation import gettext_lazy as _

    [...]

    _choices = {'1': 'One', '2': 'Two', '3': 'Three'}
    beaver_key = SettingKey(
        id='beavers-another_key',
        description=_('*Set a description here*'),
        app_label='beavers',
        type=SettingKey.INT,
        formfield_class=partial(
            forms.TypedChoiceField,
            choices=_choices.items(), coerce=int,
        ),
        html_printer=lambda value: _choices.get(value, '??'),
    )

Notice that we also provided a function which allows to correctly display
the value in the configuration block for ``SettingValue`` with the parameter
``html_printer``.


User's settings
***************

It's about every user can set its own value.

It's very similar to the previous section(the 2 APIs are voluntarily close in
order to be consistent/simple, ahd share code when it's possible).

In ``setting_keys.py`` at the app's root: ::

    from django.utils.translation import gettext_lazy as _

    from creme.creme_core.core.setting_key import UserSettingKey

    beaver_user_key = UserSettingKey(
        id='beavers-my_user_key',
        description=_('*Set a description here*'),
        app_label='beavers',
        type=UserSettingKey.BOOL,
    )


We do not create an initial value in our ``populate.py``, because users are
generally created after the app's installation.

Register the key in ``apps.py``: ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_user_setting_keys(self, user_setting_key_registry):
            from .setting_keys import beaver_user_key

            user_setting_key_registry.register(beaver_user_key)


The value can now be set by each user in its personal configuration
(Menu > Creme > My settings).

Now you can use the value in your code. Notice that an instance of
``auth.get_user_model()`` must be used ; in this example we write a view and so
we can use ``request.user``: ::

    [...]

    from .setting_keys import beaver_user_key

    [...]

    @login_required
    def a_view(request):
        [...]

        if request.user.settings.get(beaver_user_key, False):
            [...]


**A bit further** : when you instantiate a ``SettingKey``/``UserSettingKey``,
there is a parameter ``hidden``, with ``False`` as default value. If this
parameter is ``True``, Creme dies not automatically display a configuration UI
for this key ; so you can write a more adapted UI, for example :

  - to validate more finely the input values.
  - to group several keys in a same form.


Statistics brick
~~~~~~~~~~~~~~~~

There is a block which display some statistics, like the total number of
contacts for example, on the home page (or on the view «My page»).
In a fresh installation of Creme, this block is in the default configuration.

If you want to display your own statistics, you have to register in your
``beavers/apps.py`` a function which generate them like this: ::

    [...]

    class BeaversConfig(CremeAppConfig):
        [...]

        def register_statistics(self, statistic_registry):  # <- NEW
            statistic_registry.register(
                id='beavers-beavers',
                label=Beaver._meta.verbose_name_plural,
                func=lambda: [Beaver.objects.count()],
                perm='beavers',
                priority=10,
            )

Some explanations on parameters :

 - ``id`` : a unique string identifying a statistic, which allows for example
   to delete a statistic from another app. As usual, you should prefix with the
   app's name.
 - ``label`` : the name used in the brick.
 - ``func`` : a function with no argument which returns some objects to
    display ; this function will be called each time the brick is displayed.
   Here it's a list containing a simple integer, but it could contain for
   example ``string`` for more complex values (ex: «50 beavers per km²»).
 - ``perm`` : a permission ``string``, to check if the current user is allowed
   to view the statistic. Generally the permission corresponds to the app
   containing the used models.
 - ``priority`` : integer. Higher the value, higher the statistic is displayed
   in the brick.


Jobs
~~~~

Th job system manages tasks :

 - which take a long time to be completed ; a progress bar is displayed, and
   the user can change the page (or even quit its browser) without stopping the
   job. The job is correctly resumed even if the server crashes (power outage etc…).
   E.g. Creme uses these features to import CSV/XLS.
 - which have to be run periodically (or at least at a given date) without user
   trigger them. It replaces favourably a command associated to CRON rules,
   because the administrator has nothing specific to do (when it
   installs/uninstalls an app for example).
   E.g. Creme uses these features to sent the email campaigns.

Let's write the outline of a Job which performing a daily task which fetch the
health of a beaver, for example by reading a file created by another software
or by using a Web service (this part of the code won't be written here anyway).

First, we create the type of our job, which contains the task's code. Our app
must contains a package ``creme_jobs`` ; if your app get several job types, you
can use a directory ``beavers/creme_jobs/``.
Here we just create a single file ``beavers/creme_jobs.py``: ::

    from django.conf import settings
    from django.utils.translation import gettext
    from django.utils.translation import gettext_lazy as _

    from creme.creme_core.creme_jobs.base import JobType


    class _BeaversHealthType(JobType):
        id = JobType.generate_id('beavers', 'beavers_health')
        verbose_name = _('Check the health of the beavers')
        periodic = JobType.PERIODIC

        def _execute(self, job):
            [...]
            # put here the code which retrieve data

        def get_description(self, job):
            # You have to return a list of strings ; it is used in the detailed view of the job.
            # Using a list allow to return additional information like the URL of the external API.
            return [
                gettext('Check the health of the beavers by connecting to our health service'),
                gettext('URL is {}').format(settings.BEAVERS_HEALTH_URL),
            ]


    beavers_health_type = _BeaversHealthType()

    # Your package MUST contains a variable "jobs" which is a sequence
    # with instances of your types.
    # Creme fetches this variable to know the types of jobs.
    jobs = (beavers_health_type,)

**Explanations** : we define here a type of Job, which will be used by some
instances of ``creme_core.models.Job``.
As usual, we create an identifier (attribute ``id``) for our class which is
used to retrieve it from string in DB. The field ``verbose_name`` is used in
the UI to represent our job (in the list of jobs for example). The attribute
``periodic`` indicates the type of periodicity of this job type ; the value
can be :

 - ``JobType.NOT_PERIODIC`` : instances of ``Job`` with this value are created
   on-the-go, then run once as soon as possible by the jobs manager. For
   example, the CSV import works like that ; each import generates a ``Job``
   which contain all needed data (filled by the import form).
 - ``JobType.PERIODIC`` : only one instance of ``Job`` can have this type ;
   it should be created in ``populate.py`` (see after) and will be deleted when
   uninstalling the corresponding app. The job is run periodically.
   E.g. consulting an inbox, if a file is present through FTP…
 - ``JobType.PSEUDO_PERIODIC`` : as in the previous case, there is only one
   instance of ``Job`` ; it is run depending on the data stored in the DB and
   which define the next run. For example, if a job have to send emails
   in 17 hours then in 3 days.

As we created a periodic job, we must create the instance of ``Job`` in our
``beavers/populate.py``: ::

    from creme.creme_core.management.commands.creme_populate import BasePopulator
    from creme.creme_core.models import Job
    from creme.creme_core.utils.date_period import date_period_registry
    [...]

    from .creme_jobs import beavers_health_type
    [...]

    class Populator(BasePopulator):
        JOBS = [
            Job(
                type=beavers_health_type,
                # BEWARE: we must define a period
                periodicity=date_period_registry.get_period('days', 1),
            ),
        ]

        [...]


**Errors management** : your jobs will likely encounter some issues ; in our
example the Web service could be unavailable. It's a good idea to display in
the UI what happened during the last run. Most of the methods in ``JobType``
take a parameter ``job`` which is the instance of the related ``Job``. There
are some base models allowing to create some results related to this job (they
are displayed in the errors' bricks of the detailed view of the job). Here an
example: ::

    [...]
    from creme.creme_core.models import JobResult


    class _BeaversHealthType(JobType):
        [...]

        def _execute(self, job):
            try:
                [...]
            except MyConnectionError as e:
                JobResult.objects.create(
                    job=job,
                    messages=[
                        gettext('An error occurred during connection.'),
                        gettext('Original error: {}').format(e),
                    ],
                )


You can create your own exception types and your own errors' bricks
(see ``JobType.results_bricks``).

**Setting of the job** : a periodic job can be configured through a form
reachable from the list of jobs ; it allows to set the job's period. It's
possible that a job proposes a more complex configuration form, wit the
method ``JobType.get_config_form_class()`` ; additional data can be stored
in the ``Job`` instance, which owns a property ``data`` (beware data must be
compatible with JSON serialization).


Customising enumerations in filters and list-views
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It's possible to change the behaviour of enumerations related to instances
referenced by a ``ForeignKey`` (or a ``ManyToManyField``), which are used in
filter forms (e.g. choices for the field ``Beaver.status``) and the quick search
of list-views. As seen previously, these ``ForeignKey`` must have their tag
``enumerable`` to ``True`` in order to return a choices list.

If you just want to shrink the possible choices for a given ``ForeignKey``,
use the attribute "limit_choices_to" of this ``ForeignKey`` (it will affect
all forms for the corresponding model automatically).

The enumeration system of Creme is more powerful ; it allows to get more
adapted labels or to regroup some choices. For example, Creme uses it to
customise the enumeration of ``ForeignKey`` referencing the model
``EntityFilter`` (it currently only happens in the model ``reports.Report``) ;
filters are grouped by the entity type they are related to.

This is how it is made (file ``creme_core/apps.py``): ::

    def register_enumerable(self, enumerable_registry):
        from . import enumerators, models

        enumerable_registry.register_related_model(
            models.EntityFilter,
            enumerators.EntityFilterEnumerator,
        )


List of different services
~~~~~~~~~~~~~~~~~~~~~~~~~~

- You can customise the display of model fields (detailed view, list-view) with
  ``creme.creme_core.gui.field_printers.field_printer_registry``.
- You can register algorithms for email recalls with
  ``creme.creme_core.core.reminder.reminder_registry``.
- You can register new periodicity in
  ``creme.creme_core.utils.date_period.date_period_registry``.
- You can register new date ranges in
  ``creme.creme_core.utils.date_range.date_range_registry``.
- The app **billing** allows:
    - the registration of algorithms for generating invoice numbers.
      Look at ``creme/billing/apps.py``, in the method
      ``register_billing_number_generators()`` to know how to do.
    - the customisation of the documents conversion (for example Quote to
      Invoice). Look at the ``creme/billing/apps.py``, in the method
      ``register_billing_converters()`` to know how to do.
- The app **recurrents** can generate objects regularly. Look at files
  ``recurrents_register.py`` in the apps ``billing`` or ``tickets``.
- The app **crudity** can create objects from external data, like emails.


Unit tests and tests driven development
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Creme uses as many as possible the
`Test Driven Development <http://fr.wikipedia.org/wiki/Test_Driven_Development>`_
(TDD). So features' tests are written at the same time than features. So code
can be improvement with no regression, or at least they are very limited.

When you are fluent with adding code in Creme, you can consider to test and
debug your code without constantly refresh your Web browser.

For our module *beavers*, here an example which tests the creation view.
Add a file ``beavers/tests.py``: ::

    from datetime import date

    from creme.creme_core.tests.base import CremeTestCase

    from .models import Beaver, Status


    class BeaverTestCase(CremeTestCase):
        def test_createview(self):
            user = self.login_as_root_and_get()

            self.assertEqual(0, Beaver.objects.count())
            url = Beaver.get_create_absolute_url()
            self.assertGET200(url)

            name = 'Hector'
            status = Status.objects.all()[0]
            birthday = date(year=2015, month=12, day=3)
            response = self.client.post(
                url,
                follow=True,
                data={
                    'user':     user.pk,
                    'name':     name,
                    'birthday': birthday,
                    'status':   status.id,
                },
            )
            self.assertNoFormError(response)

            beavers = Beaver.objects.all()
            self.assertEqual(1, len(beavers))

            beaver = beavers[0]
            self.assertEqual(name,     beaver.name)
            self.assertEqual(status,   beaver.status)
            self.assertEqual(birthday, beaver.birthday)

To run the tests: ::

    > creme test --settings=my_project.settings beavers


**Hint** : use SQLite when you write new code. You can even, when you are in a
TDD phase (ie you don't check the result in your browser yet), avoid writing
migrations for each change in a model, with the following lines in your file
``my_project/local_settings.py`` (after the declaration of ``DATABASES`` of
course) : ::

    import sys

    if 'test' in sys.argv and DATABASES['default']['ENGINE'] == 'django.db.backends.sqlite3':
        DATABASES['default']['TEST'] = {
            'MIGRATE': False,
        }


When your code seems OK, write/generate the migrations and run tests with MySQL
and/or PostgreSQL.

**Hint** : when you run the tests with MySQL/PostgreSQL, use the option
``--keepdb`` of the command ``test`` in order to reduce the launch time of the
command after the fisrt run ; it's useful to fix failing tests (but you cannot
modify models between 2 runs).


4. Other
--------

Customisation of formats (date, number)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Note** : this section is not specific to Creme and use only tools provided
by Django ; but some Creme users will probably search here, so it could be
useful.

Date and number formats can be customised. You'll find the different keys in the
`official documentation <https://docs.djangoproject.com/en/5.2/ref/settings/#date-format>`_
de Django.

**Remark** : notice that the formats used in forms (``DATE_INPUT_FORMATS``,
``DATETIME_INPUT_FORMATS`` …) are different and distinct from the formats used
for simple display (``DATE_FORMAT``, ``DATETIME_FORMAT`` …).

The formats are different according to the user's language, so we'll logically
find them in the folders ``locale/``. You can see an example in the file
``/your/virtual/env/lib/pythonXXX/site-packages/django/conf/locale/en/formats.py``
which is used by default in english.

To use your own values (for english in this example), create first the following
files :

-  ``my_project/beavers/locale/__init__.py``
-  ``my_project/beavers/locale/en/__init__.py``
-  ``my_project/beavers/locale/en/formats.py``

In this last file, set the values you want to override. Then in your settings
set the value : ::

    FORMAT_MODULE_PATH = 'my_project.beavers.locale'
